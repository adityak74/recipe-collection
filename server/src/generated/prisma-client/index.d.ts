// Code generated by Prisma (prisma@1.28.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  alternateName: (where?: AlternateNameWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  ingredient: (where?: IngredientWhereInput) => Promise<boolean>;
  parsedSegment: (where?: ParsedSegmentWhereInput) => Promise<boolean>;
  property: (where?: PropertyWhereInput) => Promise<boolean>;
  recipe: (where?: RecipeWhereInput) => Promise<boolean>;
  recipeIngredient: (where?: RecipeIngredientWhereInput) => Promise<boolean>;
  recipeInstruction: (where?: RecipeInstructionWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  alternateName: (where: AlternateNameWhereUniqueInput) => AlternateNamePromise;
  alternateNames: (
    args?: {
      where?: AlternateNameWhereInput;
      orderBy?: AlternateNameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AlternateName>;
  alternateNamesConnection: (
    args?: {
      where?: AlternateNameWhereInput;
      orderBy?: AlternateNameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AlternateNameConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  ingredient: (where: IngredientWhereUniqueInput) => IngredientPromise;
  ingredients: (
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Ingredient>;
  ingredientsConnection: (
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IngredientConnectionPromise;
  parsedSegment: (where: ParsedSegmentWhereUniqueInput) => ParsedSegmentPromise;
  parsedSegments: (
    args?: {
      where?: ParsedSegmentWhereInput;
      orderBy?: ParsedSegmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ParsedSegment>;
  parsedSegmentsConnection: (
    args?: {
      where?: ParsedSegmentWhereInput;
      orderBy?: ParsedSegmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ParsedSegmentConnectionPromise;
  property: (where: PropertyWhereUniqueInput) => PropertyPromise;
  properties: (
    args?: {
      where?: PropertyWhereInput;
      orderBy?: PropertyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Property>;
  propertiesConnection: (
    args?: {
      where?: PropertyWhereInput;
      orderBy?: PropertyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PropertyConnectionPromise;
  recipe: (where: RecipeWhereUniqueInput) => RecipePromise;
  recipes: (
    args?: {
      where?: RecipeWhereInput;
      orderBy?: RecipeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Recipe>;
  recipesConnection: (
    args?: {
      where?: RecipeWhereInput;
      orderBy?: RecipeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RecipeConnectionPromise;
  recipeIngredient: (
    where: RecipeIngredientWhereUniqueInput
  ) => RecipeIngredientPromise;
  recipeIngredients: (
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RecipeIngredient>;
  recipeIngredientsConnection: (
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RecipeIngredientConnectionPromise;
  recipeInstruction: (
    where: RecipeInstructionWhereUniqueInput
  ) => RecipeInstructionPromise;
  recipeInstructions: (
    args?: {
      where?: RecipeInstructionWhereInput;
      orderBy?: RecipeInstructionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RecipeInstruction>;
  recipeInstructionsConnection: (
    args?: {
      where?: RecipeInstructionWhereInput;
      orderBy?: RecipeInstructionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RecipeInstructionConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlternateName: (data: AlternateNameCreateInput) => AlternateNamePromise;
  updateAlternateName: (
    args: {
      data: AlternateNameUpdateInput;
      where: AlternateNameWhereUniqueInput;
    }
  ) => AlternateNamePromise;
  updateManyAlternateNames: (
    args: {
      data: AlternateNameUpdateManyMutationInput;
      where?: AlternateNameWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAlternateName: (
    args: {
      where: AlternateNameWhereUniqueInput;
      create: AlternateNameCreateInput;
      update: AlternateNameUpdateInput;
    }
  ) => AlternateNamePromise;
  deleteAlternateName: (
    where: AlternateNameWhereUniqueInput
  ) => AlternateNamePromise;
  deleteManyAlternateNames: (
    where?: AlternateNameWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createIngredient: (data: IngredientCreateInput) => IngredientPromise;
  updateIngredient: (
    args: { data: IngredientUpdateInput; where: IngredientWhereUniqueInput }
  ) => IngredientPromise;
  updateManyIngredients: (
    args: {
      data: IngredientUpdateManyMutationInput;
      where?: IngredientWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertIngredient: (
    args: {
      where: IngredientWhereUniqueInput;
      create: IngredientCreateInput;
      update: IngredientUpdateInput;
    }
  ) => IngredientPromise;
  deleteIngredient: (where: IngredientWhereUniqueInput) => IngredientPromise;
  deleteManyIngredients: (where?: IngredientWhereInput) => BatchPayloadPromise;
  createParsedSegment: (data: ParsedSegmentCreateInput) => ParsedSegmentPromise;
  updateParsedSegment: (
    args: {
      data: ParsedSegmentUpdateInput;
      where: ParsedSegmentWhereUniqueInput;
    }
  ) => ParsedSegmentPromise;
  updateManyParsedSegments: (
    args: {
      data: ParsedSegmentUpdateManyMutationInput;
      where?: ParsedSegmentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertParsedSegment: (
    args: {
      where: ParsedSegmentWhereUniqueInput;
      create: ParsedSegmentCreateInput;
      update: ParsedSegmentUpdateInput;
    }
  ) => ParsedSegmentPromise;
  deleteParsedSegment: (
    where: ParsedSegmentWhereUniqueInput
  ) => ParsedSegmentPromise;
  deleteManyParsedSegments: (
    where?: ParsedSegmentWhereInput
  ) => BatchPayloadPromise;
  createProperty: (data: PropertyCreateInput) => PropertyPromise;
  updateProperty: (
    args: { data: PropertyUpdateInput; where: PropertyWhereUniqueInput }
  ) => PropertyPromise;
  updateManyProperties: (
    args: { data: PropertyUpdateManyMutationInput; where?: PropertyWhereInput }
  ) => BatchPayloadPromise;
  upsertProperty: (
    args: {
      where: PropertyWhereUniqueInput;
      create: PropertyCreateInput;
      update: PropertyUpdateInput;
    }
  ) => PropertyPromise;
  deleteProperty: (where: PropertyWhereUniqueInput) => PropertyPromise;
  deleteManyProperties: (where?: PropertyWhereInput) => BatchPayloadPromise;
  createRecipe: (data: RecipeCreateInput) => RecipePromise;
  updateRecipe: (
    args: { data: RecipeUpdateInput; where: RecipeWhereUniqueInput }
  ) => RecipePromise;
  updateManyRecipes: (
    args: { data: RecipeUpdateManyMutationInput; where?: RecipeWhereInput }
  ) => BatchPayloadPromise;
  upsertRecipe: (
    args: {
      where: RecipeWhereUniqueInput;
      create: RecipeCreateInput;
      update: RecipeUpdateInput;
    }
  ) => RecipePromise;
  deleteRecipe: (where: RecipeWhereUniqueInput) => RecipePromise;
  deleteManyRecipes: (where?: RecipeWhereInput) => BatchPayloadPromise;
  createRecipeIngredient: (
    data: RecipeIngredientCreateInput
  ) => RecipeIngredientPromise;
  updateRecipeIngredient: (
    args: {
      data: RecipeIngredientUpdateInput;
      where: RecipeIngredientWhereUniqueInput;
    }
  ) => RecipeIngredientPromise;
  updateManyRecipeIngredients: (
    args: {
      data: RecipeIngredientUpdateManyMutationInput;
      where?: RecipeIngredientWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRecipeIngredient: (
    args: {
      where: RecipeIngredientWhereUniqueInput;
      create: RecipeIngredientCreateInput;
      update: RecipeIngredientUpdateInput;
    }
  ) => RecipeIngredientPromise;
  deleteRecipeIngredient: (
    where: RecipeIngredientWhereUniqueInput
  ) => RecipeIngredientPromise;
  deleteManyRecipeIngredients: (
    where?: RecipeIngredientWhereInput
  ) => BatchPayloadPromise;
  createRecipeInstruction: (
    data: RecipeInstructionCreateInput
  ) => RecipeInstructionPromise;
  updateRecipeInstruction: (
    args: {
      data: RecipeInstructionUpdateInput;
      where: RecipeInstructionWhereUniqueInput;
    }
  ) => RecipeInstructionPromise;
  updateManyRecipeInstructions: (
    args: {
      data: RecipeInstructionUpdateManyMutationInput;
      where?: RecipeInstructionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRecipeInstruction: (
    args: {
      where: RecipeInstructionWhereUniqueInput;
      create: RecipeInstructionCreateInput;
      update: RecipeInstructionUpdateInput;
    }
  ) => RecipeInstructionPromise;
  deleteRecipeInstruction: (
    where: RecipeInstructionWhereUniqueInput
  ) => RecipeInstructionPromise;
  deleteManyRecipeInstructions: (
    where?: RecipeInstructionWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  alternateName: (
    where?: AlternateNameSubscriptionWhereInput
  ) => AlternateNameSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  ingredient: (
    where?: IngredientSubscriptionWhereInput
  ) => IngredientSubscriptionPayloadSubscription;
  parsedSegment: (
    where?: ParsedSegmentSubscriptionWhereInput
  ) => ParsedSegmentSubscriptionPayloadSubscription;
  property: (
    where?: PropertySubscriptionWhereInput
  ) => PropertySubscriptionPayloadSubscription;
  recipe: (
    where?: RecipeSubscriptionWhereInput
  ) => RecipeSubscriptionPayloadSubscription;
  recipeIngredient: (
    where?: RecipeIngredientSubscriptionWhereInput
  ) => RecipeIngredientSubscriptionPayloadSubscription;
  recipeInstruction: (
    where?: RecipeInstructionSubscriptionWhereInput
  ) => RecipeInstructionSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IngredientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "plural_ASC"
  | "plural_DESC"
  | "isValidated_ASC"
  | "isValidated_DESC"
  | "isComposedIngredient_ASC"
  | "isComposedIngredient_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RecipeIngredientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blockIndex_ASC"
  | "blockIndex_DESC"
  | "lineIndex_ASC"
  | "lineIndex_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "isParsed_ASC"
  | "isParsed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ParsedSegmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rule_ASC"
  | "rule_DESC"
  | "type_ASC"
  | "type_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PropertyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "meat_ASC"
  | "meat_DESC"
  | "poultry_ASC"
  | "poultry_DESC"
  | "fish_ASC"
  | "fish_DESC"
  | "dairy_ASC"
  | "dairy_DESC"
  | "soy_ASC"
  | "soy_DESC"
  | "gluten_ASC"
  | "gluten_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type RecipeInstructionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blockIndex_ASC"
  | "blockIndex_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RecipeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "title_ASC"
  | "title_DESC"
  | "source_ASC"
  | "source_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AlternateNameOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface AlternateNameUpdateDataInput {
  name?: String;
}

export type AlternateNameWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface CategoryCreateInput {
  evernoteGUID?: String;
  name: String;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface CategoryUpdateInput {
  evernoteGUID?: String;
  name?: String;
}

export interface IngredientUpdateWithoutRelatedIngredientsDataInput {
  parent?: IngredientUpdateOneWithoutParentInput;
  name?: String;
  plural?: String;
  properties?: PropertyUpdateOneRequiredInput;
  alternateNames?: AlternateNameUpdateManyInput;
  substitutes?: IngredientUpdateManyWithoutSubstitutesInput;
  references?: RecipeIngredientUpdateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface CategoryUpdateManyMutationInput {
  evernoteGUID?: String;
  name?: String;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface IngredientCreateInput {
  parent?: IngredientCreateOneWithoutParentInput;
  name: String;
  plural?: String;
  properties: PropertyCreateOneInput;
  alternateNames?: AlternateNameCreateManyInput;
  relatedIngredients?: IngredientCreateManyWithoutRelatedIngredientsInput;
  substitutes?: IngredientCreateManyWithoutSubstitutesInput;
  references?: RecipeIngredientCreateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface RecipeIngredientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RecipeIngredientWhereInput;
  AND?:
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput;
  OR?:
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput;
  NOT?:
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput;
}

export interface IngredientCreateOneWithoutParentInput {
  create?: IngredientCreateWithoutParentInput;
  connect?: IngredientWhereUniqueInput;
}

export interface RecipeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RecipeWhereInput;
  AND?: RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput;
  OR?: RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput;
  NOT?: RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput;
}

export interface IngredientCreateWithoutParentInput {
  name: String;
  plural?: String;
  properties: PropertyCreateOneInput;
  alternateNames?: AlternateNameCreateManyInput;
  relatedIngredients?: IngredientCreateManyWithoutRelatedIngredientsInput;
  substitutes?: IngredientCreateManyWithoutSubstitutesInput;
  references?: RecipeIngredientCreateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface IngredientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parent?: IngredientWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  plural?: String;
  plural_not?: String;
  plural_in?: String[] | String;
  plural_not_in?: String[] | String;
  plural_lt?: String;
  plural_lte?: String;
  plural_gt?: String;
  plural_gte?: String;
  plural_contains?: String;
  plural_not_contains?: String;
  plural_starts_with?: String;
  plural_not_starts_with?: String;
  plural_ends_with?: String;
  plural_not_ends_with?: String;
  properties?: PropertyWhereInput;
  alternateNames_every?: AlternateNameWhereInput;
  alternateNames_some?: AlternateNameWhereInput;
  alternateNames_none?: AlternateNameWhereInput;
  relatedIngredients_every?: IngredientWhereInput;
  relatedIngredients_some?: IngredientWhereInput;
  relatedIngredients_none?: IngredientWhereInput;
  substitutes_every?: IngredientWhereInput;
  substitutes_some?: IngredientWhereInput;
  substitutes_none?: IngredientWhereInput;
  references_every?: RecipeIngredientWhereInput;
  references_some?: RecipeIngredientWhereInput;
  references_none?: RecipeIngredientWhereInput;
  isValidated?: Boolean;
  isValidated_not?: Boolean;
  isComposedIngredient?: Boolean;
  isComposedIngredient_not?: Boolean;
  AND?: IngredientWhereInput[] | IngredientWhereInput;
  OR?: IngredientWhereInput[] | IngredientWhereInput;
  NOT?: IngredientWhereInput[] | IngredientWhereInput;
}

export interface PropertyCreateOneInput {
  create?: PropertyCreateInput;
  connect?: PropertyWhereUniqueInput;
}

export interface RecipeIngredientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  blockIndex?: Int;
  blockIndex_not?: Int;
  blockIndex_in?: Int[] | Int;
  blockIndex_not_in?: Int[] | Int;
  blockIndex_lt?: Int;
  blockIndex_lte?: Int;
  blockIndex_gt?: Int;
  blockIndex_gte?: Int;
  lineIndex?: Int;
  lineIndex_not?: Int;
  lineIndex_in?: Int[] | Int;
  lineIndex_not_in?: Int[] | Int;
  lineIndex_lt?: Int;
  lineIndex_lte?: Int;
  lineIndex_gt?: Int;
  lineIndex_gte?: Int;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  isParsed?: Boolean;
  isParsed_not?: Boolean;
  parsed_every?: ParsedSegmentWhereInput;
  parsed_some?: ParsedSegmentWhereInput;
  parsed_none?: ParsedSegmentWhereInput;
  AND?: RecipeIngredientWhereInput[] | RecipeIngredientWhereInput;
  OR?: RecipeIngredientWhereInput[] | RecipeIngredientWhereInput;
  NOT?: RecipeIngredientWhereInput[] | RecipeIngredientWhereInput;
}

export interface PropertyCreateInput {
  meat?: Boolean;
  poultry?: Boolean;
  fish?: Boolean;
  dairy?: Boolean;
  soy?: Boolean;
  gluten?: Boolean;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface AlternateNameCreateManyInput {
  create?: AlternateNameCreateInput[] | AlternateNameCreateInput;
  connect?: AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput;
}

export interface IngredientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IngredientWhereInput;
  AND?: IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput;
  OR?: IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput;
  NOT?: IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput;
}

export interface IngredientCreateManyWithoutRelatedIngredientsInput {
  create?:
    | IngredientCreateWithoutRelatedIngredientsInput[]
    | IngredientCreateWithoutRelatedIngredientsInput;
  connect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
}

export interface AlternateNameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AlternateNameWhereInput;
  AND?:
    | AlternateNameSubscriptionWhereInput[]
    | AlternateNameSubscriptionWhereInput;
  OR?:
    | AlternateNameSubscriptionWhereInput[]
    | AlternateNameSubscriptionWhereInput;
  NOT?:
    | AlternateNameSubscriptionWhereInput[]
    | AlternateNameSubscriptionWhereInput;
}

export interface IngredientCreateWithoutRelatedIngredientsInput {
  parent?: IngredientCreateOneWithoutParentInput;
  name: String;
  plural?: String;
  properties: PropertyCreateOneInput;
  alternateNames?: AlternateNameCreateManyInput;
  substitutes?: IngredientCreateManyWithoutSubstitutesInput;
  references?: RecipeIngredientCreateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface UserUpdateInput {
  name?: String;
}

export interface IngredientCreateManyWithoutSubstitutesInput {
  create?:
    | IngredientCreateWithoutSubstitutesInput[]
    | IngredientCreateWithoutSubstitutesInput;
  connect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
}

export type ParsedSegmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface IngredientCreateWithoutSubstitutesInput {
  parent?: IngredientCreateOneWithoutParentInput;
  name: String;
  plural?: String;
  properties: PropertyCreateOneInput;
  alternateNames?: AlternateNameCreateManyInput;
  relatedIngredients?: IngredientCreateManyWithoutRelatedIngredientsInput;
  references?: RecipeIngredientCreateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface TagUpdateInput {
  evernoteGUID?: String;
  name?: String;
}

export interface RecipeIngredientCreateManyInput {
  create?: RecipeIngredientCreateInput[] | RecipeIngredientCreateInput;
  connect?:
    | RecipeIngredientWhereUniqueInput[]
    | RecipeIngredientWhereUniqueInput;
}

export type PropertyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RecipeIngredientCreateInput {
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed?: Boolean;
  parsed?: ParsedSegmentCreateManyInput;
}

export interface RecipeIngredientUpdateManyMutationInput {
  blockIndex?: Int;
  lineIndex?: Int;
  reference?: String;
  isParsed?: Boolean;
}

export interface ParsedSegmentCreateManyInput {
  create?: ParsedSegmentCreateInput[] | ParsedSegmentCreateInput;
  connect?: ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput;
}

export interface RecipeUpdateManyMutationInput {
  evernoteGUID?: String;
  title?: String;
  source?: String;
  image?: String;
}

export interface ParsedSegmentCreateInput {
  rule: String;
  type: String;
  value: String;
  ingredient?: IngredientCreateOneInput;
}

export interface RecipeInstructionUpdateManyDataInput {
  blockIndex?: Int;
  reference?: String;
}

export interface IngredientCreateOneInput {
  create?: IngredientCreateInput;
  connect?: IngredientWhereUniqueInput;
}

export interface RecipeInstructionUpdateManyWithWhereNestedInput {
  where: RecipeInstructionScalarWhereInput;
  data: RecipeInstructionUpdateManyDataInput;
}

export interface IngredientUpdateInput {
  parent?: IngredientUpdateOneWithoutParentInput;
  name?: String;
  plural?: String;
  properties?: PropertyUpdateOneRequiredInput;
  alternateNames?: AlternateNameUpdateManyInput;
  relatedIngredients?: IngredientUpdateManyWithoutRelatedIngredientsInput;
  substitutes?: IngredientUpdateManyWithoutSubstitutesInput;
  references?: RecipeIngredientUpdateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface RecipeInstructionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  blockIndex?: Int;
  blockIndex_not?: Int;
  blockIndex_in?: Int[] | Int;
  blockIndex_not_in?: Int[] | Int;
  blockIndex_lt?: Int;
  blockIndex_lte?: Int;
  blockIndex_gt?: Int;
  blockIndex_gte?: Int;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  AND?: RecipeInstructionWhereInput[] | RecipeInstructionWhereInput;
  OR?: RecipeInstructionWhereInput[] | RecipeInstructionWhereInput;
  NOT?: RecipeInstructionWhereInput[] | RecipeInstructionWhereInput;
}

export interface IngredientUpdateOneWithoutParentInput {
  create?: IngredientCreateWithoutParentInput;
  update?: IngredientUpdateWithoutParentDataInput;
  upsert?: IngredientUpsertWithoutParentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: IngredientWhereUniqueInput;
}

export interface RecipeInstructionUpdateDataInput {
  blockIndex?: Int;
  reference?: String;
}

export interface IngredientUpdateWithoutParentDataInput {
  name?: String;
  plural?: String;
  properties?: PropertyUpdateOneRequiredInput;
  alternateNames?: AlternateNameUpdateManyInput;
  relatedIngredients?: IngredientUpdateManyWithoutRelatedIngredientsInput;
  substitutes?: IngredientUpdateManyWithoutSubstitutesInput;
  references?: RecipeIngredientUpdateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface RecipeInstructionUpdateWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput;
  data: RecipeInstructionUpdateDataInput;
}

export interface PropertyUpdateOneRequiredInput {
  create?: PropertyCreateInput;
  update?: PropertyUpdateDataInput;
  upsert?: PropertyUpsertNestedInput;
  connect?: PropertyWhereUniqueInput;
}

export interface TagUpdateManyDataInput {
  evernoteGUID?: String;
  name?: String;
}

export interface PropertyUpdateDataInput {
  meat?: Boolean;
  poultry?: Boolean;
  fish?: Boolean;
  dairy?: Boolean;
  soy?: Boolean;
  gluten?: Boolean;
}

export type RecipeIngredientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PropertyUpsertNestedInput {
  update: PropertyUpdateDataInput;
  create: PropertyCreateInput;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface AlternateNameUpdateManyInput {
  create?: AlternateNameCreateInput[] | AlternateNameCreateInput;
  update?:
    | AlternateNameUpdateWithWhereUniqueNestedInput[]
    | AlternateNameUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AlternateNameUpsertWithWhereUniqueNestedInput[]
    | AlternateNameUpsertWithWhereUniqueNestedInput;
  delete?: AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput;
  connect?: AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput;
  set?: AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput;
  disconnect?: AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput;
  deleteMany?: AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput;
  updateMany?:
    | AlternateNameUpdateManyWithWhereNestedInput[]
    | AlternateNameUpdateManyWithWhereNestedInput;
}

export type RecipeInstructionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AlternateNameUpdateWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput;
  data: AlternateNameUpdateDataInput;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagCreateInput {
  evernoteGUID?: String;
  name: String;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface AlternateNameUpsertWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput;
  update: AlternateNameUpdateDataInput;
  create: AlternateNameCreateInput;
}

export interface CategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  evernoteGUID?: String;
  evernoteGUID_not?: String;
  evernoteGUID_in?: String[] | String;
  evernoteGUID_not_in?: String[] | String;
  evernoteGUID_lt?: String;
  evernoteGUID_lte?: String;
  evernoteGUID_gt?: String;
  evernoteGUID_gte?: String;
  evernoteGUID_contains?: String;
  evernoteGUID_not_contains?: String;
  evernoteGUID_starts_with?: String;
  evernoteGUID_not_starts_with?: String;
  evernoteGUID_ends_with?: String;
  evernoteGUID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  OR?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  NOT?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
}

export interface AlternateNameScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput;
  OR?: AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput;
  NOT?: AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AlternateNameUpdateManyWithWhereNestedInput {
  where: AlternateNameScalarWhereInput;
  data: AlternateNameUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AlternateNameUpdateManyDataInput {
  name?: String;
}

export interface CategoryUpdateWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateDataInput;
}

export interface IngredientUpdateManyWithoutRelatedIngredientsInput {
  create?:
    | IngredientCreateWithoutRelatedIngredientsInput[]
    | IngredientCreateWithoutRelatedIngredientsInput;
  delete?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  connect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  set?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  disconnect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  update?:
    | IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput[]
    | IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput;
  upsert?:
    | IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput[]
    | IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput;
  deleteMany?: IngredientScalarWhereInput[] | IngredientScalarWhereInput;
  updateMany?:
    | IngredientUpdateManyWithWhereNestedInput[]
    | IngredientUpdateManyWithWhereNestedInput;
}

export interface RecipeUpdateInput {
  evernoteGUID?: String;
  title?: String;
  source?: String;
  image?: String;
  categories?: CategoryUpdateManyInput;
  tags?: TagUpdateManyInput;
  ingredients?: RecipeIngredientUpdateManyInput;
  instructions?: RecipeInstructionUpdateManyInput;
}

export interface IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput;
  data: IngredientUpdateWithoutRelatedIngredientsDataInput;
}

export interface AlternateNameCreateInput {
  name: String;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  evernoteGUID?: String;
  evernoteGUID_not?: String;
  evernoteGUID_in?: String[] | String;
  evernoteGUID_not_in?: String[] | String;
  evernoteGUID_lt?: String;
  evernoteGUID_lte?: String;
  evernoteGUID_gt?: String;
  evernoteGUID_gte?: String;
  evernoteGUID_contains?: String;
  evernoteGUID_not_contains?: String;
  evernoteGUID_starts_with?: String;
  evernoteGUID_not_starts_with?: String;
  evernoteGUID_ends_with?: String;
  evernoteGUID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface AlternateNameUpdateManyMutationInput {
  name?: String;
}

export interface IngredientUpdateManyWithoutSubstitutesInput {
  create?:
    | IngredientCreateWithoutSubstitutesInput[]
    | IngredientCreateWithoutSubstitutesInput;
  delete?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  connect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  set?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  disconnect?: IngredientWhereUniqueInput[] | IngredientWhereUniqueInput;
  update?:
    | IngredientUpdateWithWhereUniqueWithoutSubstitutesInput[]
    | IngredientUpdateWithWhereUniqueWithoutSubstitutesInput;
  upsert?:
    | IngredientUpsertWithWhereUniqueWithoutSubstitutesInput[]
    | IngredientUpsertWithWhereUniqueWithoutSubstitutesInput;
  deleteMany?: IngredientScalarWhereInput[] | IngredientScalarWhereInput;
  updateMany?:
    | IngredientUpdateManyWithWhereNestedInput[]
    | IngredientUpdateManyWithWhereNestedInput;
}

export interface RecipeInstructionCreateManyInput {
  create?: RecipeInstructionCreateInput[] | RecipeInstructionCreateInput;
  connect?:
    | RecipeInstructionWhereUniqueInput[]
    | RecipeInstructionWhereUniqueInput;
}

export interface IngredientUpdateWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput;
  data: IngredientUpdateWithoutSubstitutesDataInput;
}

export interface RecipeInstructionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RecipeInstructionWhereInput;
  AND?:
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput;
  OR?:
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput;
  NOT?:
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput;
}

export interface IngredientUpdateWithoutSubstitutesDataInput {
  parent?: IngredientUpdateOneWithoutParentInput;
  name?: String;
  plural?: String;
  properties?: PropertyUpdateOneRequiredInput;
  alternateNames?: AlternateNameUpdateManyInput;
  relatedIngredients?: IngredientUpdateManyWithoutRelatedIngredientsInput;
  references?: RecipeIngredientUpdateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface PropertySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PropertyWhereInput;
  AND?: PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput;
  OR?: PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput;
  NOT?: PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput;
}

export interface RecipeIngredientUpdateManyInput {
  create?: RecipeIngredientCreateInput[] | RecipeIngredientCreateInput;
  update?:
    | RecipeIngredientUpdateWithWhereUniqueNestedInput[]
    | RecipeIngredientUpdateWithWhereUniqueNestedInput;
  upsert?:
    | RecipeIngredientUpsertWithWhereUniqueNestedInput[]
    | RecipeIngredientUpsertWithWhereUniqueNestedInput;
  delete?:
    | RecipeIngredientWhereUniqueInput[]
    | RecipeIngredientWhereUniqueInput;
  connect?:
    | RecipeIngredientWhereUniqueInput[]
    | RecipeIngredientWhereUniqueInput;
  set?: RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput;
  disconnect?:
    | RecipeIngredientWhereUniqueInput[]
    | RecipeIngredientWhereUniqueInput;
  deleteMany?:
    | RecipeIngredientScalarWhereInput[]
    | RecipeIngredientScalarWhereInput;
  updateMany?:
    | RecipeIngredientUpdateManyWithWhereNestedInput[]
    | RecipeIngredientUpdateManyWithWhereNestedInput;
}

export interface ParsedSegmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rule?: String;
  rule_not?: String;
  rule_in?: String[] | String;
  rule_not_in?: String[] | String;
  rule_lt?: String;
  rule_lte?: String;
  rule_gt?: String;
  rule_gte?: String;
  rule_contains?: String;
  rule_not_contains?: String;
  rule_starts_with?: String;
  rule_not_starts_with?: String;
  rule_ends_with?: String;
  rule_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  ingredient?: IngredientWhereInput;
  AND?: ParsedSegmentWhereInput[] | ParsedSegmentWhereInput;
  OR?: ParsedSegmentWhereInput[] | ParsedSegmentWhereInput;
  NOT?: ParsedSegmentWhereInput[] | ParsedSegmentWhereInput;
}

export interface RecipeIngredientUpdateWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput;
  data: RecipeIngredientUpdateDataInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface RecipeIngredientUpdateDataInput {
  blockIndex?: Int;
  lineIndex?: Int;
  reference?: String;
  isParsed?: Boolean;
  parsed?: ParsedSegmentUpdateManyInput;
}

export interface UserCreateInput {
  name: String;
}

export interface ParsedSegmentUpdateManyInput {
  create?: ParsedSegmentCreateInput[] | ParsedSegmentCreateInput;
  update?:
    | ParsedSegmentUpdateWithWhereUniqueNestedInput[]
    | ParsedSegmentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ParsedSegmentUpsertWithWhereUniqueNestedInput[]
    | ParsedSegmentUpsertWithWhereUniqueNestedInput;
  delete?: ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput;
  connect?: ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput;
  set?: ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput;
  disconnect?: ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput;
  deleteMany?: ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput;
  updateMany?:
    | ParsedSegmentUpdateManyWithWhereNestedInput[]
    | ParsedSegmentUpdateManyWithWhereNestedInput;
}

export interface RecipeInstructionUpdateManyMutationInput {
  blockIndex?: Int;
  reference?: String;
}

export interface ParsedSegmentUpdateWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput;
  data: ParsedSegmentUpdateDataInput;
}

export interface RecipeIngredientUpdateInput {
  blockIndex?: Int;
  lineIndex?: Int;
  reference?: String;
  isParsed?: Boolean;
  parsed?: ParsedSegmentUpdateManyInput;
}

export interface ParsedSegmentUpdateDataInput {
  rule?: String;
  type?: String;
  value?: String;
  ingredient?: IngredientUpdateOneInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  evernoteGUID?: String;
  evernoteGUID_not?: String;
  evernoteGUID_in?: String[] | String;
  evernoteGUID_not_in?: String[] | String;
  evernoteGUID_lt?: String;
  evernoteGUID_lte?: String;
  evernoteGUID_gt?: String;
  evernoteGUID_gte?: String;
  evernoteGUID_contains?: String;
  evernoteGUID_not_contains?: String;
  evernoteGUID_starts_with?: String;
  evernoteGUID_not_starts_with?: String;
  evernoteGUID_ends_with?: String;
  evernoteGUID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface IngredientUpdateOneInput {
  create?: IngredientCreateInput;
  update?: IngredientUpdateDataInput;
  upsert?: IngredientUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: IngredientWhereUniqueInput;
}

export interface RecipeInstructionUpsertWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput;
  update: RecipeInstructionUpdateDataInput;
  create: RecipeInstructionCreateInput;
}

export interface IngredientUpdateDataInput {
  parent?: IngredientUpdateOneWithoutParentInput;
  name?: String;
  plural?: String;
  properties?: PropertyUpdateOneRequiredInput;
  alternateNames?: AlternateNameUpdateManyInput;
  relatedIngredients?: IngredientUpdateManyWithoutRelatedIngredientsInput;
  substitutes?: IngredientUpdateManyWithoutSubstitutesInput;
  references?: RecipeIngredientUpdateManyInput;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface RecipeInstructionUpdateManyInput {
  create?: RecipeInstructionCreateInput[] | RecipeInstructionCreateInput;
  update?:
    | RecipeInstructionUpdateWithWhereUniqueNestedInput[]
    | RecipeInstructionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | RecipeInstructionUpsertWithWhereUniqueNestedInput[]
    | RecipeInstructionUpsertWithWhereUniqueNestedInput;
  delete?:
    | RecipeInstructionWhereUniqueInput[]
    | RecipeInstructionWhereUniqueInput;
  connect?:
    | RecipeInstructionWhereUniqueInput[]
    | RecipeInstructionWhereUniqueInput;
  set?: RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput;
  disconnect?:
    | RecipeInstructionWhereUniqueInput[]
    | RecipeInstructionWhereUniqueInput;
  deleteMany?:
    | RecipeInstructionScalarWhereInput[]
    | RecipeInstructionScalarWhereInput;
  updateMany?:
    | RecipeInstructionUpdateManyWithWhereNestedInput[]
    | RecipeInstructionUpdateManyWithWhereNestedInput;
}

export interface IngredientUpsertNestedInput {
  update: IngredientUpdateDataInput;
  create: IngredientCreateInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  evernoteGUID?: String;
  evernoteGUID_not?: String;
  evernoteGUID_in?: String[] | String;
  evernoteGUID_not_in?: String[] | String;
  evernoteGUID_lt?: String;
  evernoteGUID_lte?: String;
  evernoteGUID_gt?: String;
  evernoteGUID_gte?: String;
  evernoteGUID_contains?: String;
  evernoteGUID_not_contains?: String;
  evernoteGUID_starts_with?: String;
  evernoteGUID_not_starts_with?: String;
  evernoteGUID_ends_with?: String;
  evernoteGUID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface ParsedSegmentUpsertWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput;
  update: ParsedSegmentUpdateDataInput;
  create: ParsedSegmentCreateInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface ParsedSegmentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rule?: String;
  rule_not?: String;
  rule_in?: String[] | String;
  rule_not_in?: String[] | String;
  rule_lt?: String;
  rule_lte?: String;
  rule_gt?: String;
  rule_gte?: String;
  rule_contains?: String;
  rule_not_contains?: String;
  rule_starts_with?: String;
  rule_not_starts_with?: String;
  rule_ends_with?: String;
  rule_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput;
  OR?: ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput;
  NOT?: ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface ParsedSegmentUpdateManyWithWhereNestedInput {
  where: ParsedSegmentScalarWhereInput;
  data: ParsedSegmentUpdateManyDataInput;
}

export interface CategoryUpdateDataInput {
  evernoteGUID?: String;
  name?: String;
}

export interface ParsedSegmentUpdateManyDataInput {
  rule?: String;
  type?: String;
  value?: String;
}

export interface CategoryUpdateManyInput {
  create?: CategoryCreateInput[] | CategoryCreateInput;
  update?:
    | CategoryUpdateWithWhereUniqueNestedInput[]
    | CategoryUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueNestedInput[]
    | CategoryUpsertWithWhereUniqueNestedInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export interface RecipeIngredientUpsertWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput;
  update: RecipeIngredientUpdateDataInput;
  create: RecipeIngredientCreateInput;
}

export interface AlternateNameUpdateInput {
  name?: String;
}

export interface RecipeIngredientScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  blockIndex?: Int;
  blockIndex_not?: Int;
  blockIndex_in?: Int[] | Int;
  blockIndex_not_in?: Int[] | Int;
  blockIndex_lt?: Int;
  blockIndex_lte?: Int;
  blockIndex_gt?: Int;
  blockIndex_gte?: Int;
  lineIndex?: Int;
  lineIndex_not?: Int;
  lineIndex_in?: Int[] | Int;
  lineIndex_not_in?: Int[] | Int;
  lineIndex_lt?: Int;
  lineIndex_lte?: Int;
  lineIndex_gt?: Int;
  lineIndex_gte?: Int;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  isParsed?: Boolean;
  isParsed_not?: Boolean;
  AND?: RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput;
  OR?: RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput;
  NOT?: RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface RecipeIngredientUpdateManyWithWhereNestedInput {
  where: RecipeIngredientScalarWhereInput;
  data: RecipeIngredientUpdateManyDataInput;
}

export interface PropertyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  meat?: Boolean;
  meat_not?: Boolean;
  poultry?: Boolean;
  poultry_not?: Boolean;
  fish?: Boolean;
  fish_not?: Boolean;
  dairy?: Boolean;
  dairy_not?: Boolean;
  soy?: Boolean;
  soy_not?: Boolean;
  gluten?: Boolean;
  gluten_not?: Boolean;
  AND?: PropertyWhereInput[] | PropertyWhereInput;
  OR?: PropertyWhereInput[] | PropertyWhereInput;
  NOT?: PropertyWhereInput[] | PropertyWhereInput;
}

export interface RecipeIngredientUpdateManyDataInput {
  blockIndex?: Int;
  lineIndex?: Int;
  reference?: String;
  isParsed?: Boolean;
}

export interface UserUpdateManyMutationInput {
  name?: String;
}

export interface IngredientUpsertWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput;
  update: IngredientUpdateWithoutSubstitutesDataInput;
  create: IngredientCreateWithoutSubstitutesInput;
}

export interface RecipeInstructionUpdateInput {
  blockIndex?: Int;
  reference?: String;
}

export interface IngredientScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  plural?: String;
  plural_not?: String;
  plural_in?: String[] | String;
  plural_not_in?: String[] | String;
  plural_lt?: String;
  plural_lte?: String;
  plural_gt?: String;
  plural_gte?: String;
  plural_contains?: String;
  plural_not_contains?: String;
  plural_starts_with?: String;
  plural_not_starts_with?: String;
  plural_ends_with?: String;
  plural_not_ends_with?: String;
  isValidated?: Boolean;
  isValidated_not?: Boolean;
  isComposedIngredient?: Boolean;
  isComposedIngredient_not?: Boolean;
  AND?: IngredientScalarWhereInput[] | IngredientScalarWhereInput;
  OR?: IngredientScalarWhereInput[] | IngredientScalarWhereInput;
  NOT?: IngredientScalarWhereInput[] | IngredientScalarWhereInput;
}

export interface RecipeInstructionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  blockIndex?: Int;
  blockIndex_not?: Int;
  blockIndex_in?: Int[] | Int;
  blockIndex_not_in?: Int[] | Int;
  blockIndex_lt?: Int;
  blockIndex_lte?: Int;
  blockIndex_gt?: Int;
  blockIndex_gte?: Int;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  AND?: RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput;
  OR?: RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput;
  NOT?: RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput;
}

export interface IngredientUpdateManyWithWhereNestedInput {
  where: IngredientScalarWhereInput;
  data: IngredientUpdateManyDataInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface IngredientUpdateManyDataInput {
  name?: String;
  plural?: String;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface CategoryUpdateManyDataInput {
  evernoteGUID?: String;
  name?: String;
}

export interface IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput;
  update: IngredientUpdateWithoutRelatedIngredientsDataInput;
  create: IngredientCreateWithoutRelatedIngredientsInput;
}

export interface AlternateNameWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AlternateNameWhereInput[] | AlternateNameWhereInput;
  OR?: AlternateNameWhereInput[] | AlternateNameWhereInput;
  NOT?: AlternateNameWhereInput[] | AlternateNameWhereInput;
}

export interface IngredientUpsertWithoutParentInput {
  update: IngredientUpdateWithoutParentDataInput;
  create: IngredientCreateWithoutParentInput;
}

export interface RecipeInstructionCreateInput {
  blockIndex: Int;
  reference: String;
}

export interface IngredientUpdateManyMutationInput {
  name?: String;
  plural?: String;
  isValidated?: Boolean;
  isComposedIngredient?: Boolean;
}

export interface ParsedSegmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParsedSegmentWhereInput;
  AND?:
    | ParsedSegmentSubscriptionWhereInput[]
    | ParsedSegmentSubscriptionWhereInput;
  OR?:
    | ParsedSegmentSubscriptionWhereInput[]
    | ParsedSegmentSubscriptionWhereInput;
  NOT?:
    | ParsedSegmentSubscriptionWhereInput[]
    | ParsedSegmentSubscriptionWhereInput;
}

export interface ParsedSegmentUpdateInput {
  rule?: String;
  type?: String;
  value?: String;
  ingredient?: IngredientUpdateOneInput;
}

export type RecipeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParsedSegmentUpdateManyMutationInput {
  rule?: String;
  type?: String;
  value?: String;
}

export interface TagUpdateDataInput {
  evernoteGUID?: String;
  name?: String;
}

export interface CategoryCreateManyInput {
  create?: CategoryCreateInput[] | CategoryCreateInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export interface RecipeCreateInput {
  evernoteGUID?: String;
  title: String;
  source?: String;
  image?: String;
  categories?: CategoryCreateManyInput;
  tags?: TagCreateManyInput;
  ingredients?: RecipeIngredientCreateManyInput;
  instructions?: RecipeInstructionCreateManyInput;
}

export interface PropertyUpdateManyMutationInput {
  meat?: Boolean;
  poultry?: Boolean;
  fish?: Boolean;
  dairy?: Boolean;
  soy?: Boolean;
  gluten?: Boolean;
}

export interface PropertyUpdateInput {
  meat?: Boolean;
  poultry?: Boolean;
  fish?: Boolean;
  dairy?: Boolean;
  soy?: Boolean;
  gluten?: Boolean;
}

export type IngredientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  plural?: String;
}>;

export interface CategoryUpsertWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface RecipeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  evernoteGUID?: String;
  evernoteGUID_not?: String;
  evernoteGUID_in?: String[] | String;
  evernoteGUID_not_in?: String[] | String;
  evernoteGUID_lt?: String;
  evernoteGUID_lte?: String;
  evernoteGUID_gt?: String;
  evernoteGUID_gte?: String;
  evernoteGUID_contains?: String;
  evernoteGUID_not_contains?: String;
  evernoteGUID_starts_with?: String;
  evernoteGUID_not_starts_with?: String;
  evernoteGUID_ends_with?: String;
  evernoteGUID_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  categories_every?: CategoryWhereInput;
  categories_some?: CategoryWhereInput;
  categories_none?: CategoryWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  ingredients_every?: RecipeIngredientWhereInput;
  ingredients_some?: RecipeIngredientWhereInput;
  ingredients_none?: RecipeIngredientWhereInput;
  instructions_every?: RecipeInstructionWhereInput;
  instructions_some?: RecipeInstructionWhereInput;
  instructions_none?: RecipeInstructionWhereInput;
  AND?: RecipeWhereInput[] | RecipeWhereInput;
  OR?: RecipeWhereInput[] | RecipeWhereInput;
  NOT?: RecipeWhereInput[] | RecipeWhereInput;
}

export interface TagUpdateManyMutationInput {
  evernoteGUID?: String;
  name?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface IngredientEdge {
  node: Ingredient;
  cursor: String;
}

export interface IngredientEdgePromise
  extends Promise<IngredientEdge>,
    Fragmentable {
  node: <T = IngredientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IngredientEdgeSubscription
  extends Promise<AsyncIterator<IngredientEdge>>,
    Fragmentable {
  node: <T = IngredientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Category {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface IngredientConnection {
  pageInfo: PageInfo;
  edges: IngredientEdge[];
}

export interface IngredientConnectionPromise
  extends Promise<IngredientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IngredientEdge>>() => T;
  aggregate: <T = AggregateIngredientPromise>() => T;
}

export interface IngredientConnectionSubscription
  extends Promise<AsyncIterator<IngredientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IngredientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIngredientSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ParsedSegment {
  id: ID_Output;
  rule: String;
  type: String;
  value: String;
}

export interface ParsedSegmentPromise
  extends Promise<ParsedSegment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rule: () => Promise<String>;
  type: () => Promise<String>;
  value: () => Promise<String>;
  ingredient: <T = IngredientPromise>() => T;
}

export interface ParsedSegmentSubscription
  extends Promise<AsyncIterator<ParsedSegment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rule: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  ingredient: <T = IngredientSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlternateName {
  name: String;
}

export interface AlternateNamePromise
  extends Promise<AlternateName>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface AlternateNameSubscription
  extends Promise<AsyncIterator<AlternateName>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AlternateNameSubscriptionPayload {
  mutation: MutationType;
  node: AlternateName;
  updatedFields: String[];
  previousValues: AlternateNamePreviousValues;
}

export interface AlternateNameSubscriptionPayloadPromise
  extends Promise<AlternateNameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlternateNamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlternateNamePreviousValuesPromise>() => T;
}

export interface AlternateNameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlternateNameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlternateNameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlternateNamePreviousValuesSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlternateNamePreviousValues {
  name: String;
}

export interface AlternateNamePreviousValuesPromise
  extends Promise<AlternateNamePreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
}

export interface AlternateNamePreviousValuesSubscription
  extends Promise<AsyncIterator<AlternateNamePreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRecipeInstruction {
  count: Int;
}

export interface AggregateRecipeInstructionPromise
  extends Promise<AggregateRecipeInstruction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeInstructionSubscription
  extends Promise<AsyncIterator<AggregateRecipeInstruction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlternateNameEdge {
  node: AlternateName;
  cursor: String;
}

export interface AlternateNameEdgePromise
  extends Promise<AlternateNameEdge>,
    Fragmentable {
  node: <T = AlternateNamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlternateNameEdgeSubscription
  extends Promise<AsyncIterator<AlternateNameEdge>>,
    Fragmentable {
  node: <T = AlternateNameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeInstructionConnection {
  pageInfo: PageInfo;
  edges: RecipeInstructionEdge[];
}

export interface RecipeInstructionConnectionPromise
  extends Promise<RecipeInstructionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeInstructionEdge>>() => T;
  aggregate: <T = AggregateRecipeInstructionPromise>() => T;
}

export interface RecipeInstructionConnectionSubscription
  extends Promise<AsyncIterator<RecipeInstructionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeInstructionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeInstructionSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface RecipeIngredientEdge {
  node: RecipeIngredient;
  cursor: String;
}

export interface RecipeIngredientEdgePromise
  extends Promise<RecipeIngredientEdge>,
    Fragmentable {
  node: <T = RecipeIngredientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeIngredientEdgeSubscription
  extends Promise<AsyncIterator<RecipeIngredientEdge>>,
    Fragmentable {
  node: <T = RecipeIngredientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRecipe {
  count: Int;
}

export interface AggregateRecipePromise
  extends Promise<AggregateRecipe>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeSubscription
  extends Promise<AsyncIterator<AggregateRecipe>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeIngredient {
  id: ID_Output;
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed: Boolean;
}

export interface RecipeIngredientPromise
  extends Promise<RecipeIngredient>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  lineIndex: () => Promise<Int>;
  reference: () => Promise<String>;
  isParsed: () => Promise<Boolean>;
  parsed: <T = FragmentableArray<ParsedSegment>>(
    args?: {
      where?: ParsedSegmentWhereInput;
      orderBy?: ParsedSegmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RecipeIngredientSubscription
  extends Promise<AsyncIterator<RecipeIngredient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  lineIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
  isParsed: () => Promise<AsyncIterator<Boolean>>;
  parsed: <T = Promise<AsyncIterator<ParsedSegmentSubscription>>>(
    args?: {
      where?: ParsedSegmentWhereInput;
      orderBy?: ParsedSegmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RecipeConnection {
  pageInfo: PageInfo;
  edges: RecipeEdge[];
}

export interface RecipeConnectionPromise
  extends Promise<RecipeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeEdge>>() => T;
  aggregate: <T = AggregateRecipePromise>() => T;
}

export interface RecipeConnectionSubscription
  extends Promise<AsyncIterator<RecipeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeSubscription>() => T;
}

export interface IngredientSubscriptionPayload {
  mutation: MutationType;
  node: Ingredient;
  updatedFields: String[];
  previousValues: IngredientPreviousValues;
}

export interface IngredientSubscriptionPayloadPromise
  extends Promise<IngredientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IngredientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IngredientPreviousValuesPromise>() => T;
}

export interface IngredientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IngredientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IngredientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IngredientPreviousValuesSubscription>() => T;
}

export interface RecipeInstruction {
  id: ID_Output;
  blockIndex: Int;
  reference: String;
}

export interface RecipeInstructionPromise
  extends Promise<RecipeInstruction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  reference: () => Promise<String>;
}

export interface RecipeInstructionSubscription
  extends Promise<AsyncIterator<RecipeInstruction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface IngredientPreviousValues {
  id: ID_Output;
  name: String;
  plural?: String;
  isValidated: Boolean;
  isComposedIngredient: Boolean;
}

export interface IngredientPreviousValuesPromise
  extends Promise<IngredientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  plural: () => Promise<String>;
  isValidated: () => Promise<Boolean>;
  isComposedIngredient: () => Promise<Boolean>;
}

export interface IngredientPreviousValuesSubscription
  extends Promise<AsyncIterator<IngredientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  plural: () => Promise<AsyncIterator<String>>;
  isValidated: () => Promise<AsyncIterator<Boolean>>;
  isComposedIngredient: () => Promise<AsyncIterator<Boolean>>;
}

export interface Tag {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAlternateName {
  count: Int;
}

export interface AggregateAlternateNamePromise
  extends Promise<AggregateAlternateName>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlternateNameSubscription
  extends Promise<AsyncIterator<AggregateAlternateName>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Recipe {
  id: ID_Output;
  evernoteGUID?: String;
  title: String;
  source?: String;
  image?: String;
}

export interface RecipePromise extends Promise<Recipe>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  title: () => Promise<String>;
  source: () => Promise<String>;
  image: () => Promise<String>;
  categories: <T = FragmentableArray<Category>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  ingredients: <T = FragmentableArray<RecipeIngredient>>(
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instructions: <T = FragmentableArray<RecipeInstruction>>(
    args?: {
      where?: RecipeInstructionWhereInput;
      orderBy?: RecipeInstructionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RecipeSubscription
  extends Promise<AsyncIterator<Recipe>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  ingredients: <T = Promise<AsyncIterator<RecipeIngredientSubscription>>>(
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instructions: <T = Promise<AsyncIterator<RecipeInstructionSubscription>>>(
    args?: {
      where?: RecipeInstructionWhereInput;
      orderBy?: RecipeInstructionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ParsedSegmentSubscriptionPayload {
  mutation: MutationType;
  node: ParsedSegment;
  updatedFields: String[];
  previousValues: ParsedSegmentPreviousValues;
}

export interface ParsedSegmentSubscriptionPayloadPromise
  extends Promise<ParsedSegmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParsedSegmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParsedSegmentPreviousValuesPromise>() => T;
}

export interface ParsedSegmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParsedSegmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParsedSegmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParsedSegmentPreviousValuesSubscription>() => T;
}

export interface PropertyEdge {
  node: Property;
  cursor: String;
}

export interface PropertyEdgePromise
  extends Promise<PropertyEdge>,
    Fragmentable {
  node: <T = PropertyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PropertyEdgeSubscription
  extends Promise<AsyncIterator<PropertyEdge>>,
    Fragmentable {
  node: <T = PropertySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProperty {
  count: Int;
}

export interface AggregatePropertyPromise
  extends Promise<AggregateProperty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePropertySubscription
  extends Promise<AsyncIterator<AggregateProperty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface PropertyConnection {
  pageInfo: PageInfo;
  edges: PropertyEdge[];
}

export interface PropertyConnectionPromise
  extends Promise<PropertyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PropertyEdge>>() => T;
  aggregate: <T = AggregatePropertyPromise>() => T;
}

export interface PropertyConnectionSubscription
  extends Promise<AsyncIterator<PropertyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PropertyEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePropertySubscription>() => T;
}

export interface ParsedSegmentPreviousValues {
  id: ID_Output;
  rule: String;
  type: String;
  value: String;
}

export interface ParsedSegmentPreviousValuesPromise
  extends Promise<ParsedSegmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rule: () => Promise<String>;
  type: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ParsedSegmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParsedSegmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rule: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParsedSegment {
  count: Int;
}

export interface AggregateParsedSegmentPromise
  extends Promise<AggregateParsedSegment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParsedSegmentSubscription
  extends Promise<AsyncIterator<AggregateParsedSegment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParsedSegmentConnection {
  pageInfo: PageInfo;
  edges: ParsedSegmentEdge[];
}

export interface ParsedSegmentConnectionPromise
  extends Promise<ParsedSegmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParsedSegmentEdge>>() => T;
  aggregate: <T = AggregateParsedSegmentPromise>() => T;
}

export interface ParsedSegmentConnectionSubscription
  extends Promise<AsyncIterator<ParsedSegmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParsedSegmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParsedSegmentSubscription>() => T;
}

export interface Property {
  id: ID_Output;
  meat: Boolean;
  poultry: Boolean;
  fish: Boolean;
  dairy: Boolean;
  soy: Boolean;
  gluten: Boolean;
}

export interface PropertyPromise extends Promise<Property>, Fragmentable {
  id: () => Promise<ID_Output>;
  meat: () => Promise<Boolean>;
  poultry: () => Promise<Boolean>;
  fish: () => Promise<Boolean>;
  dairy: () => Promise<Boolean>;
  soy: () => Promise<Boolean>;
  gluten: () => Promise<Boolean>;
}

export interface PropertySubscription
  extends Promise<AsyncIterator<Property>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  meat: () => Promise<AsyncIterator<Boolean>>;
  poultry: () => Promise<AsyncIterator<Boolean>>;
  fish: () => Promise<AsyncIterator<Boolean>>;
  dairy: () => Promise<AsyncIterator<Boolean>>;
  soy: () => Promise<AsyncIterator<Boolean>>;
  gluten: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PropertySubscriptionPayload {
  mutation: MutationType;
  node: Property;
  updatedFields: String[];
  previousValues: PropertyPreviousValues;
}

export interface PropertySubscriptionPayloadPromise
  extends Promise<PropertySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PropertyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PropertyPreviousValuesPromise>() => T;
}

export interface PropertySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PropertySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PropertySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PropertyPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PropertyPreviousValues {
  id: ID_Output;
  meat: Boolean;
  poultry: Boolean;
  fish: Boolean;
  dairy: Boolean;
  soy: Boolean;
  gluten: Boolean;
}

export interface PropertyPreviousValuesPromise
  extends Promise<PropertyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  meat: () => Promise<Boolean>;
  poultry: () => Promise<Boolean>;
  fish: () => Promise<Boolean>;
  dairy: () => Promise<Boolean>;
  soy: () => Promise<Boolean>;
  gluten: () => Promise<Boolean>;
}

export interface PropertyPreviousValuesSubscription
  extends Promise<AsyncIterator<PropertyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  meat: () => Promise<AsyncIterator<Boolean>>;
  poultry: () => Promise<AsyncIterator<Boolean>>;
  fish: () => Promise<AsyncIterator<Boolean>>;
  dairy: () => Promise<AsyncIterator<Boolean>>;
  soy: () => Promise<AsyncIterator<Boolean>>;
  gluten: () => Promise<AsyncIterator<Boolean>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface Ingredient {
  id: ID_Output;
  name: String;
  plural?: String;
  isValidated: Boolean;
  isComposedIngredient: Boolean;
}

export interface IngredientPromise extends Promise<Ingredient>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = IngredientPromise>() => T;
  name: () => Promise<String>;
  plural: () => Promise<String>;
  properties: <T = PropertyPromise>() => T;
  alternateNames: <T = FragmentableArray<AlternateName>>(
    args?: {
      where?: AlternateNameWhereInput;
      orderBy?: AlternateNameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  relatedIngredients: <T = FragmentableArray<Ingredient>>(
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  substitutes: <T = FragmentableArray<Ingredient>>(
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  references: <T = FragmentableArray<RecipeIngredient>>(
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isValidated: () => Promise<Boolean>;
  isComposedIngredient: () => Promise<Boolean>;
}

export interface IngredientSubscription
  extends Promise<AsyncIterator<Ingredient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = IngredientSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  plural: () => Promise<AsyncIterator<String>>;
  properties: <T = PropertySubscription>() => T;
  alternateNames: <T = Promise<AsyncIterator<AlternateNameSubscription>>>(
    args?: {
      where?: AlternateNameWhereInput;
      orderBy?: AlternateNameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  relatedIngredients: <T = Promise<AsyncIterator<IngredientSubscription>>>(
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  substitutes: <T = Promise<AsyncIterator<IngredientSubscription>>>(
    args?: {
      where?: IngredientWhereInput;
      orderBy?: IngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  references: <T = Promise<AsyncIterator<RecipeIngredientSubscription>>>(
    args?: {
      where?: RecipeIngredientWhereInput;
      orderBy?: RecipeIngredientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isValidated: () => Promise<AsyncIterator<Boolean>>;
  isComposedIngredient: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateRecipeIngredient {
  count: Int;
}

export interface AggregateRecipeIngredientPromise
  extends Promise<AggregateRecipeIngredient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeIngredientSubscription
  extends Promise<AsyncIterator<AggregateRecipeIngredient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeSubscriptionPayload {
  mutation: MutationType;
  node: Recipe;
  updatedFields: String[];
  previousValues: RecipePreviousValues;
}

export interface RecipeSubscriptionPayloadPromise
  extends Promise<RecipeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipePreviousValuesPromise>() => T;
}

export interface RecipeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipePreviousValuesSubscription>() => T;
}

export interface RecipeEdge {
  node: Recipe;
  cursor: String;
}

export interface RecipeEdgePromise extends Promise<RecipeEdge>, Fragmentable {
  node: <T = RecipePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeEdgeSubscription
  extends Promise<AsyncIterator<RecipeEdge>>,
    Fragmentable {
  node: <T = RecipeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipePreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  title: String;
  source?: String;
  image?: String;
}

export interface RecipePreviousValuesPromise
  extends Promise<RecipePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  title: () => Promise<String>;
  source: () => Promise<String>;
  image: () => Promise<String>;
}

export interface RecipePreviousValuesSubscription
  extends Promise<AsyncIterator<RecipePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface AlternateNameConnection {
  pageInfo: PageInfo;
  edges: AlternateNameEdge[];
}

export interface AlternateNameConnectionPromise
  extends Promise<AlternateNameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlternateNameEdge>>() => T;
  aggregate: <T = AggregateAlternateNamePromise>() => T;
}

export interface AlternateNameConnectionSubscription
  extends Promise<AsyncIterator<AlternateNameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlternateNameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlternateNameSubscription>() => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParsedSegmentEdge {
  node: ParsedSegment;
  cursor: String;
}

export interface ParsedSegmentEdgePromise
  extends Promise<ParsedSegmentEdge>,
    Fragmentable {
  node: <T = ParsedSegmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParsedSegmentEdgeSubscription
  extends Promise<AsyncIterator<ParsedSegmentEdge>>,
    Fragmentable {
  node: <T = ParsedSegmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeIngredientSubscriptionPayload {
  mutation: MutationType;
  node: RecipeIngredient;
  updatedFields: String[];
  previousValues: RecipeIngredientPreviousValues;
}

export interface RecipeIngredientSubscriptionPayloadPromise
  extends Promise<RecipeIngredientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipeIngredientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipeIngredientPreviousValuesPromise>() => T;
}

export interface RecipeIngredientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeIngredientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeIngredientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipeIngredientPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeIngredientPreviousValues {
  id: ID_Output;
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed: Boolean;
}

export interface RecipeIngredientPreviousValuesPromise
  extends Promise<RecipeIngredientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  lineIndex: () => Promise<Int>;
  reference: () => Promise<String>;
  isParsed: () => Promise<Boolean>;
}

export interface RecipeIngredientPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipeIngredientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  lineIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
  isParsed: () => Promise<AsyncIterator<Boolean>>;
}

export interface RecipeInstructionEdge {
  node: RecipeInstruction;
  cursor: String;
}

export interface RecipeInstructionEdgePromise
  extends Promise<RecipeInstructionEdge>,
    Fragmentable {
  node: <T = RecipeInstructionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeInstructionEdgeSubscription
  extends Promise<AsyncIterator<RecipeInstructionEdge>>,
    Fragmentable {
  node: <T = RecipeInstructionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface RecipeInstructionPreviousValues {
  id: ID_Output;
  blockIndex: Int;
  reference: String;
}

export interface RecipeInstructionPreviousValuesPromise
  extends Promise<RecipeInstructionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  reference: () => Promise<String>;
}

export interface RecipeInstructionPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipeInstructionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface RecipeInstructionSubscriptionPayload {
  mutation: MutationType;
  node: RecipeInstruction;
  updatedFields: String[];
  previousValues: RecipeInstructionPreviousValues;
}

export interface RecipeInstructionSubscriptionPayloadPromise
  extends Promise<RecipeInstructionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipeInstructionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipeInstructionPreviousValuesPromise>() => T;
}

export interface RecipeInstructionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeInstructionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeInstructionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipeInstructionPreviousValuesSubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeIngredientConnection {
  pageInfo: PageInfo;
  edges: RecipeIngredientEdge[];
}

export interface RecipeIngredientConnectionPromise
  extends Promise<RecipeIngredientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeIngredientEdge>>() => T;
  aggregate: <T = AggregateRecipeIngredientPromise>() => T;
}

export interface RecipeIngredientConnectionSubscription
  extends Promise<AsyncIterator<RecipeIngredientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeIngredientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeIngredientSubscription>() => T;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateIngredient {
  count: Int;
}

export interface AggregateIngredientPromise
  extends Promise<AggregateIngredient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIngredientSubscription
  extends Promise<AsyncIterator<AggregateIngredient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Ingredient",
    embedded: false
  },
  {
    name: "AlternateName",
    embedded: false
  },
  {
    name: "Property",
    embedded: false
  },
  {
    name: "Recipe",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "RecipeIngredient",
    embedded: false
  },
  {
    name: "RecipeInstruction",
    embedded: false
  },
  {
    name: "ParsedSegment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
