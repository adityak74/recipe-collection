// Code generated by Prisma (prisma@1.34.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  alternateName: (where?: AlternateNameWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  ingredient: (where?: IngredientWhereInput) => Promise<boolean>;
  ingredientAggregate: (
    where?: IngredientAggregateWhereInput
  ) => Promise<boolean>;
  parsedSegment: (where?: ParsedSegmentWhereInput) => Promise<boolean>;
  properties: (where?: PropertiesWhereInput) => Promise<boolean>;
  recipe: (where?: RecipeWhereInput) => Promise<boolean>;
  recipeAggregate: (where?: RecipeAggregateWhereInput) => Promise<boolean>;
  recipeIngredient: (where?: RecipeIngredientWhereInput) => Promise<boolean>;
  recipeInstruction: (where?: RecipeInstructionWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  alternateName: (
    where: AlternateNameWhereUniqueInput
  ) => AlternateNameNullablePromise;
  alternateNames: (args?: {
    where?: AlternateNameWhereInput;
    orderBy?: AlternateNameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AlternateName>;
  alternateNamesConnection: (args?: {
    where?: AlternateNameWhereInput;
    orderBy?: AlternateNameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AlternateNameConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  ingredient: (where: IngredientWhereUniqueInput) => IngredientNullablePromise;
  ingredients: (args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ingredient>;
  ingredientsConnection: (args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IngredientConnectionPromise;
  ingredientAggregate: (
    where: IngredientAggregateWhereUniqueInput
  ) => IngredientAggregateNullablePromise;
  ingredientAggregates: (args?: {
    where?: IngredientAggregateWhereInput;
    orderBy?: IngredientAggregateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<IngredientAggregate>;
  ingredientAggregatesConnection: (args?: {
    where?: IngredientAggregateWhereInput;
    orderBy?: IngredientAggregateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IngredientAggregateConnectionPromise;
  parsedSegment: (
    where: ParsedSegmentWhereUniqueInput
  ) => ParsedSegmentNullablePromise;
  parsedSegments: (args?: {
    where?: ParsedSegmentWhereInput;
    orderBy?: ParsedSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ParsedSegment>;
  parsedSegmentsConnection: (args?: {
    where?: ParsedSegmentWhereInput;
    orderBy?: ParsedSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParsedSegmentConnectionPromise;
  properties: (where: PropertiesWhereUniqueInput) => PropertiesNullablePromise;
  propertieses: (args?: {
    where?: PropertiesWhereInput;
    orderBy?: PropertiesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Properties>;
  propertiesesConnection: (args?: {
    where?: PropertiesWhereInput;
    orderBy?: PropertiesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PropertiesConnectionPromise;
  recipe: (where: RecipeWhereUniqueInput) => RecipeNullablePromise;
  recipes: (args?: {
    where?: RecipeWhereInput;
    orderBy?: RecipeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Recipe>;
  recipesConnection: (args?: {
    where?: RecipeWhereInput;
    orderBy?: RecipeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RecipeConnectionPromise;
  recipeAggregate: (
    where: RecipeAggregateWhereUniqueInput
  ) => RecipeAggregateNullablePromise;
  recipeAggregates: (args?: {
    where?: RecipeAggregateWhereInput;
    orderBy?: RecipeAggregateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RecipeAggregate>;
  recipeAggregatesConnection: (args?: {
    where?: RecipeAggregateWhereInput;
    orderBy?: RecipeAggregateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RecipeAggregateConnectionPromise;
  recipeIngredient: (
    where: RecipeIngredientWhereUniqueInput
  ) => RecipeIngredientNullablePromise;
  recipeIngredients: (args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RecipeIngredient>;
  recipeIngredientsConnection: (args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RecipeIngredientConnectionPromise;
  recipeInstruction: (
    where: RecipeInstructionWhereUniqueInput
  ) => RecipeInstructionNullablePromise;
  recipeInstructions: (args?: {
    where?: RecipeInstructionWhereInput;
    orderBy?: RecipeInstructionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RecipeInstruction>;
  recipeInstructionsConnection: (args?: {
    where?: RecipeInstructionWhereInput;
    orderBy?: RecipeInstructionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RecipeInstructionConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlternateName: (data: AlternateNameCreateInput) => AlternateNamePromise;
  updateAlternateName: (args: {
    data: AlternateNameUpdateInput;
    where: AlternateNameWhereUniqueInput;
  }) => AlternateNamePromise;
  updateManyAlternateNames: (args: {
    data: AlternateNameUpdateManyMutationInput;
    where?: AlternateNameWhereInput;
  }) => BatchPayloadPromise;
  upsertAlternateName: (args: {
    where: AlternateNameWhereUniqueInput;
    create: AlternateNameCreateInput;
    update: AlternateNameUpdateInput;
  }) => AlternateNamePromise;
  deleteAlternateName: (
    where: AlternateNameWhereUniqueInput
  ) => AlternateNamePromise;
  deleteManyAlternateNames: (
    where?: AlternateNameWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createIngredient: (data: IngredientCreateInput) => IngredientPromise;
  updateIngredient: (args: {
    data: IngredientUpdateInput;
    where: IngredientWhereUniqueInput;
  }) => IngredientPromise;
  updateManyIngredients: (args: {
    data: IngredientUpdateManyMutationInput;
    where?: IngredientWhereInput;
  }) => BatchPayloadPromise;
  upsertIngredient: (args: {
    where: IngredientWhereUniqueInput;
    create: IngredientCreateInput;
    update: IngredientUpdateInput;
  }) => IngredientPromise;
  deleteIngredient: (where: IngredientWhereUniqueInput) => IngredientPromise;
  deleteManyIngredients: (where?: IngredientWhereInput) => BatchPayloadPromise;
  createIngredientAggregate: (
    data: IngredientAggregateCreateInput
  ) => IngredientAggregatePromise;
  updateIngredientAggregate: (args: {
    data: IngredientAggregateUpdateInput;
    where: IngredientAggregateWhereUniqueInput;
  }) => IngredientAggregatePromise;
  updateManyIngredientAggregates: (args: {
    data: IngredientAggregateUpdateManyMutationInput;
    where?: IngredientAggregateWhereInput;
  }) => BatchPayloadPromise;
  upsertIngredientAggregate: (args: {
    where: IngredientAggregateWhereUniqueInput;
    create: IngredientAggregateCreateInput;
    update: IngredientAggregateUpdateInput;
  }) => IngredientAggregatePromise;
  deleteIngredientAggregate: (
    where: IngredientAggregateWhereUniqueInput
  ) => IngredientAggregatePromise;
  deleteManyIngredientAggregates: (
    where?: IngredientAggregateWhereInput
  ) => BatchPayloadPromise;
  createParsedSegment: (data: ParsedSegmentCreateInput) => ParsedSegmentPromise;
  updateParsedSegment: (args: {
    data: ParsedSegmentUpdateInput;
    where: ParsedSegmentWhereUniqueInput;
  }) => ParsedSegmentPromise;
  updateManyParsedSegments: (args: {
    data: ParsedSegmentUpdateManyMutationInput;
    where?: ParsedSegmentWhereInput;
  }) => BatchPayloadPromise;
  upsertParsedSegment: (args: {
    where: ParsedSegmentWhereUniqueInput;
    create: ParsedSegmentCreateInput;
    update: ParsedSegmentUpdateInput;
  }) => ParsedSegmentPromise;
  deleteParsedSegment: (
    where: ParsedSegmentWhereUniqueInput
  ) => ParsedSegmentPromise;
  deleteManyParsedSegments: (
    where?: ParsedSegmentWhereInput
  ) => BatchPayloadPromise;
  createProperties: (data: PropertiesCreateInput) => PropertiesPromise;
  updateProperties: (args: {
    data: PropertiesUpdateInput;
    where: PropertiesWhereUniqueInput;
  }) => PropertiesPromise;
  updateManyPropertieses: (args: {
    data: PropertiesUpdateManyMutationInput;
    where?: PropertiesWhereInput;
  }) => BatchPayloadPromise;
  upsertProperties: (args: {
    where: PropertiesWhereUniqueInput;
    create: PropertiesCreateInput;
    update: PropertiesUpdateInput;
  }) => PropertiesPromise;
  deleteProperties: (where: PropertiesWhereUniqueInput) => PropertiesPromise;
  deleteManyPropertieses: (where?: PropertiesWhereInput) => BatchPayloadPromise;
  createRecipe: (data: RecipeCreateInput) => RecipePromise;
  updateRecipe: (args: {
    data: RecipeUpdateInput;
    where: RecipeWhereUniqueInput;
  }) => RecipePromise;
  updateManyRecipes: (args: {
    data: RecipeUpdateManyMutationInput;
    where?: RecipeWhereInput;
  }) => BatchPayloadPromise;
  upsertRecipe: (args: {
    where: RecipeWhereUniqueInput;
    create: RecipeCreateInput;
    update: RecipeUpdateInput;
  }) => RecipePromise;
  deleteRecipe: (where: RecipeWhereUniqueInput) => RecipePromise;
  deleteManyRecipes: (where?: RecipeWhereInput) => BatchPayloadPromise;
  createRecipeAggregate: (
    data: RecipeAggregateCreateInput
  ) => RecipeAggregatePromise;
  updateRecipeAggregate: (args: {
    data: RecipeAggregateUpdateInput;
    where: RecipeAggregateWhereUniqueInput;
  }) => RecipeAggregatePromise;
  updateManyRecipeAggregates: (args: {
    data: RecipeAggregateUpdateManyMutationInput;
    where?: RecipeAggregateWhereInput;
  }) => BatchPayloadPromise;
  upsertRecipeAggregate: (args: {
    where: RecipeAggregateWhereUniqueInput;
    create: RecipeAggregateCreateInput;
    update: RecipeAggregateUpdateInput;
  }) => RecipeAggregatePromise;
  deleteRecipeAggregate: (
    where: RecipeAggregateWhereUniqueInput
  ) => RecipeAggregatePromise;
  deleteManyRecipeAggregates: (
    where?: RecipeAggregateWhereInput
  ) => BatchPayloadPromise;
  createRecipeIngredient: (
    data: RecipeIngredientCreateInput
  ) => RecipeIngredientPromise;
  updateRecipeIngredient: (args: {
    data: RecipeIngredientUpdateInput;
    where: RecipeIngredientWhereUniqueInput;
  }) => RecipeIngredientPromise;
  updateManyRecipeIngredients: (args: {
    data: RecipeIngredientUpdateManyMutationInput;
    where?: RecipeIngredientWhereInput;
  }) => BatchPayloadPromise;
  upsertRecipeIngredient: (args: {
    where: RecipeIngredientWhereUniqueInput;
    create: RecipeIngredientCreateInput;
    update: RecipeIngredientUpdateInput;
  }) => RecipeIngredientPromise;
  deleteRecipeIngredient: (
    where: RecipeIngredientWhereUniqueInput
  ) => RecipeIngredientPromise;
  deleteManyRecipeIngredients: (
    where?: RecipeIngredientWhereInput
  ) => BatchPayloadPromise;
  createRecipeInstruction: (
    data: RecipeInstructionCreateInput
  ) => RecipeInstructionPromise;
  updateRecipeInstruction: (args: {
    data: RecipeInstructionUpdateInput;
    where: RecipeInstructionWhereUniqueInput;
  }) => RecipeInstructionPromise;
  updateManyRecipeInstructions: (args: {
    data: RecipeInstructionUpdateManyMutationInput;
    where?: RecipeInstructionWhereInput;
  }) => BatchPayloadPromise;
  upsertRecipeInstruction: (args: {
    where: RecipeInstructionWhereUniqueInput;
    create: RecipeInstructionCreateInput;
    update: RecipeInstructionUpdateInput;
  }) => RecipeInstructionPromise;
  deleteRecipeInstruction: (
    where: RecipeInstructionWhereUniqueInput
  ) => RecipeInstructionPromise;
  deleteManyRecipeInstructions: (
    where?: RecipeInstructionWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  alternateName: (
    where?: AlternateNameSubscriptionWhereInput
  ) => AlternateNameSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  ingredient: (
    where?: IngredientSubscriptionWhereInput
  ) => IngredientSubscriptionPayloadSubscription;
  ingredientAggregate: (
    where?: IngredientAggregateSubscriptionWhereInput
  ) => IngredientAggregateSubscriptionPayloadSubscription;
  parsedSegment: (
    where?: ParsedSegmentSubscriptionWhereInput
  ) => ParsedSegmentSubscriptionPayloadSubscription;
  properties: (
    where?: PropertiesSubscriptionWhereInput
  ) => PropertiesSubscriptionPayloadSubscription;
  recipe: (
    where?: RecipeSubscriptionWhereInput
  ) => RecipeSubscriptionPayloadSubscription;
  recipeAggregate: (
    where?: RecipeAggregateSubscriptionWhereInput
  ) => RecipeAggregateSubscriptionPayloadSubscription;
  recipeIngredient: (
    where?: RecipeIngredientSubscriptionWhereInput
  ) => RecipeIngredientSubscriptionPayloadSubscription;
  recipeInstruction: (
    where?: RecipeInstructionSubscriptionWhereInput
  ) => RecipeInstructionSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "name_ASC"
  | "name_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "name_ASC"
  | "name_DESC";

export type PropertiesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "meat_ASC"
  | "meat_DESC"
  | "poultry_ASC"
  | "poultry_DESC"
  | "fish_ASC"
  | "fish_DESC"
  | "dairy_ASC"
  | "dairy_DESC"
  | "soy_ASC"
  | "soy_DESC"
  | "gluten_ASC"
  | "gluten_DESC";

export type RecipeAggregateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "recipesCount_ASC"
  | "recipesCount_DESC";

export type IngredientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "plural_ASC"
  | "plural_DESC"
  | "isComposedIngredient_ASC"
  | "isComposedIngredient_DESC"
  | "isValidated_ASC"
  | "isValidated_DESC";

export type RecipeIngredientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blockIndex_ASC"
  | "blockIndex_DESC"
  | "lineIndex_ASC"
  | "lineIndex_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "isParsed_ASC"
  | "isParsed_DESC";

export type ParsedSegmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rule_ASC"
  | "rule_DESC"
  | "type_ASC"
  | "type_DESC"
  | "value_ASC"
  | "value_DESC";

export type IngredientAggregateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ingredientsCount_ASC"
  | "ingredientsCount_DESC"
  | "newIngredientsCount_ASC"
  | "newIngredientsCount_DESC";

export type RecipeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "evernoteGUID_ASC"
  | "evernoteGUID_DESC"
  | "title_ASC"
  | "title_DESC"
  | "source_ASC"
  | "source_DESC"
  | "image_ASC"
  | "image_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type RecipeInstructionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blockIndex_ASC"
  | "blockIndex_DESC"
  | "reference_ASC"
  | "reference_DESC";

export type AlternateNameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export interface PropertiesUpdateOneRequiredInput {
  create?: Maybe<PropertiesCreateInput>;
  update?: Maybe<PropertiesUpdateDataInput>;
  upsert?: Maybe<PropertiesUpsertNestedInput>;
  connect?: Maybe<PropertiesWhereUniqueInput>;
}

export type AlternateNameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface IngredientUpdateWithoutRelatedIngredientsDataInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameUpdateManyInput>;
  properties?: Maybe<PropertiesUpdateOneRequiredInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientUpdateOneWithoutParentInput>;
  substitutes?: Maybe<IngredientUpdateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientUpdateManyInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  evernoteGUID_not?: Maybe<String>;
  evernoteGUID_in?: Maybe<String[] | String>;
  evernoteGUID_not_in?: Maybe<String[] | String>;
  evernoteGUID_lt?: Maybe<String>;
  evernoteGUID_lte?: Maybe<String>;
  evernoteGUID_gt?: Maybe<String>;
  evernoteGUID_gte?: Maybe<String>;
  evernoteGUID_contains?: Maybe<String>;
  evernoteGUID_not_contains?: Maybe<String>;
  evernoteGUID_starts_with?: Maybe<String>;
  evernoteGUID_not_starts_with?: Maybe<String>;
  evernoteGUID_ends_with?: Maybe<String>;
  evernoteGUID_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface RecipeInstructionCreateManyInput {
  create?: Maybe<RecipeInstructionCreateInput[] | RecipeInstructionCreateInput>;
  connect?: Maybe<
    RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput
  >;
}

export interface PropertiesUpdateManyMutationInput {
  meat?: Maybe<Boolean>;
  poultry?: Maybe<Boolean>;
  fish?: Maybe<Boolean>;
  dairy?: Maybe<Boolean>;
  soy?: Maybe<Boolean>;
  gluten?: Maybe<Boolean>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  name: String;
}

export interface IngredientUpdateManyWithoutSubstitutesInput {
  create?: Maybe<
    | IngredientCreateWithoutSubstitutesInput[]
    | IngredientCreateWithoutSubstitutesInput
  >;
  delete?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  connect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  set?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  disconnect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  update?: Maybe<
    | IngredientUpdateWithWhereUniqueWithoutSubstitutesInput[]
    | IngredientUpdateWithWhereUniqueWithoutSubstitutesInput
  >;
  upsert?: Maybe<
    | IngredientUpsertWithWhereUniqueWithoutSubstitutesInput[]
    | IngredientUpsertWithWhereUniqueWithoutSubstitutesInput
  >;
  deleteMany?: Maybe<IngredientScalarWhereInput[] | IngredientScalarWhereInput>;
  updateMany?: Maybe<
    | IngredientUpdateManyWithWhereNestedInput[]
    | IngredientUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  name: String;
}

export type IngredientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  plural?: Maybe<String>;
}>;

export interface CategoryUpdateInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface RecipeIngredientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RecipeIngredientWhereInput>;
  AND?: Maybe<
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RecipeIngredientSubscriptionWhereInput[]
    | RecipeIngredientSubscriptionWhereInput
  >;
}

export interface CategoryUpdateManyMutationInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface PropertiesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  meat?: Maybe<Boolean>;
  meat_not?: Maybe<Boolean>;
  poultry?: Maybe<Boolean>;
  poultry_not?: Maybe<Boolean>;
  fish?: Maybe<Boolean>;
  fish_not?: Maybe<Boolean>;
  dairy?: Maybe<Boolean>;
  dairy_not?: Maybe<Boolean>;
  soy?: Maybe<Boolean>;
  soy_not?: Maybe<Boolean>;
  gluten?: Maybe<Boolean>;
  gluten_not?: Maybe<Boolean>;
  AND?: Maybe<PropertiesWhereInput[] | PropertiesWhereInput>;
  OR?: Maybe<PropertiesWhereInput[] | PropertiesWhereInput>;
  NOT?: Maybe<PropertiesWhereInput[] | PropertiesWhereInput>;
}

export interface IngredientCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameCreateManyInput>;
  properties: PropertiesCreateOneInput;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientCreateOneWithoutParentInput>;
  relatedIngredients?: Maybe<
    IngredientCreateManyWithoutRelatedIngredientsInput
  >;
  substitutes?: Maybe<IngredientCreateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientCreateManyInput>;
}

export interface ParsedSegmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rule?: Maybe<String>;
  rule_not?: Maybe<String>;
  rule_in?: Maybe<String[] | String>;
  rule_not_in?: Maybe<String[] | String>;
  rule_lt?: Maybe<String>;
  rule_lte?: Maybe<String>;
  rule_gt?: Maybe<String>;
  rule_gte?: Maybe<String>;
  rule_contains?: Maybe<String>;
  rule_not_contains?: Maybe<String>;
  rule_starts_with?: Maybe<String>;
  rule_not_starts_with?: Maybe<String>;
  rule_ends_with?: Maybe<String>;
  rule_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  ingredient?: Maybe<IngredientWhereInput>;
  AND?: Maybe<ParsedSegmentWhereInput[] | ParsedSegmentWhereInput>;
  OR?: Maybe<ParsedSegmentWhereInput[] | ParsedSegmentWhereInput>;
  NOT?: Maybe<ParsedSegmentWhereInput[] | ParsedSegmentWhereInput>;
}

export interface AlternateNameCreateManyInput {
  create?: Maybe<AlternateNameCreateInput[] | AlternateNameCreateInput>;
  connect?: Maybe<
    AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput
  >;
}

export interface RecipeAggregateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RecipeAggregateWhereInput>;
  AND?: Maybe<
    | RecipeAggregateSubscriptionWhereInput[]
    | RecipeAggregateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RecipeAggregateSubscriptionWhereInput[]
    | RecipeAggregateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RecipeAggregateSubscriptionWhereInput[]
    | RecipeAggregateSubscriptionWhereInput
  >;
}

export interface PropertiesCreateOneInput {
  create?: Maybe<PropertiesCreateInput>;
  connect?: Maybe<PropertiesWhereUniqueInput>;
}

export interface PropertiesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PropertiesWhereInput>;
  AND?: Maybe<
    PropertiesSubscriptionWhereInput[] | PropertiesSubscriptionWhereInput
  >;
  OR?: Maybe<
    PropertiesSubscriptionWhereInput[] | PropertiesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PropertiesSubscriptionWhereInput[] | PropertiesSubscriptionWhereInput
  >;
}

export interface PropertiesCreateInput {
  id?: Maybe<ID_Input>;
  meat?: Maybe<Boolean>;
  poultry?: Maybe<Boolean>;
  fish?: Maybe<Boolean>;
  dairy?: Maybe<Boolean>;
  soy?: Maybe<Boolean>;
  gluten?: Maybe<Boolean>;
}

export interface IngredientAggregateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IngredientAggregateWhereInput>;
  AND?: Maybe<
    | IngredientAggregateSubscriptionWhereInput[]
    | IngredientAggregateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | IngredientAggregateSubscriptionWhereInput[]
    | IngredientAggregateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | IngredientAggregateSubscriptionWhereInput[]
    | IngredientAggregateSubscriptionWhereInput
  >;
}

export interface IngredientCreateOneWithoutParentInput {
  create?: Maybe<IngredientCreateWithoutParentInput>;
  connect?: Maybe<IngredientWhereUniqueInput>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface IngredientCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name: String;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameCreateManyInput>;
  properties: PropertiesCreateOneInput;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  relatedIngredients?: Maybe<
    IngredientCreateManyWithoutRelatedIngredientsInput
  >;
  substitutes?: Maybe<IngredientCreateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientCreateManyInput>;
}

export interface AlternateNameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AlternateNameWhereInput>;
  AND?: Maybe<
    AlternateNameSubscriptionWhereInput[] | AlternateNameSubscriptionWhereInput
  >;
  OR?: Maybe<
    AlternateNameSubscriptionWhereInput[] | AlternateNameSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AlternateNameSubscriptionWhereInput[] | AlternateNameSubscriptionWhereInput
  >;
}

export interface IngredientCreateManyWithoutRelatedIngredientsInput {
  create?: Maybe<
    | IngredientCreateWithoutRelatedIngredientsInput[]
    | IngredientCreateWithoutRelatedIngredientsInput
  >;
  connect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
}

export interface TagUpdateManyMutationInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface IngredientCreateWithoutRelatedIngredientsInput {
  id?: Maybe<ID_Input>;
  name: String;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameCreateManyInput>;
  properties: PropertiesCreateOneInput;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientCreateOneWithoutParentInput>;
  substitutes?: Maybe<IngredientCreateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientCreateManyInput>;
}

export interface RecipeInstructionUpdateManyMutationInput {
  blockIndex?: Maybe<Int>;
  reference?: Maybe<String>;
}

export interface IngredientCreateManyWithoutSubstitutesInput {
  create?: Maybe<
    | IngredientCreateWithoutSubstitutesInput[]
    | IngredientCreateWithoutSubstitutesInput
  >;
  connect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
}

export type ParsedSegmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IngredientCreateWithoutSubstitutesInput {
  id?: Maybe<ID_Input>;
  name: String;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameCreateManyInput>;
  properties: PropertiesCreateOneInput;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientCreateOneWithoutParentInput>;
  relatedIngredients?: Maybe<
    IngredientCreateManyWithoutRelatedIngredientsInput
  >;
  references?: Maybe<RecipeIngredientCreateManyInput>;
}

export interface RecipeIngredientUpdateInput {
  blockIndex?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  reference?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
  parsed?: Maybe<ParsedSegmentUpdateManyInput>;
}

export interface RecipeIngredientCreateManyInput {
  create?: Maybe<RecipeIngredientCreateInput[] | RecipeIngredientCreateInput>;
  connect?: Maybe<
    RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput
  >;
}

export type PropertiesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RecipeIngredientCreateInput {
  id?: Maybe<ID_Input>;
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed?: Maybe<Boolean>;
  parsed?: Maybe<ParsedSegmentCreateManyInput>;
}

export interface RecipeAggregateCreateInput {
  id?: Maybe<ID_Input>;
  recipesCount: Int;
}

export interface ParsedSegmentCreateManyInput {
  create?: Maybe<ParsedSegmentCreateInput[] | ParsedSegmentCreateInput>;
  connect?: Maybe<
    ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput
  >;
}

export interface RecipeInstructionUpdateManyDataInput {
  blockIndex?: Maybe<Int>;
  reference?: Maybe<String>;
}

export interface ParsedSegmentCreateInput {
  id?: Maybe<ID_Input>;
  rule: String;
  type: String;
  value: String;
  ingredient?: Maybe<IngredientCreateOneInput>;
}

export interface RecipeInstructionUpdateManyWithWhereNestedInput {
  where: RecipeInstructionScalarWhereInput;
  data: RecipeInstructionUpdateManyDataInput;
}

export interface IngredientCreateOneInput {
  create?: Maybe<IngredientCreateInput>;
  connect?: Maybe<IngredientWhereUniqueInput>;
}

export interface RecipeInstructionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockIndex?: Maybe<Int>;
  blockIndex_not?: Maybe<Int>;
  blockIndex_in?: Maybe<Int[] | Int>;
  blockIndex_not_in?: Maybe<Int[] | Int>;
  blockIndex_lt?: Maybe<Int>;
  blockIndex_lte?: Maybe<Int>;
  blockIndex_gt?: Maybe<Int>;
  blockIndex_gte?: Maybe<Int>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput
  >;
  OR?: Maybe<
    RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput
  >;
  NOT?: Maybe<
    RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput
  >;
}

export interface IngredientUpdateInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameUpdateManyInput>;
  properties?: Maybe<PropertiesUpdateOneRequiredInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientUpdateOneWithoutParentInput>;
  relatedIngredients?: Maybe<
    IngredientUpdateManyWithoutRelatedIngredientsInput
  >;
  substitutes?: Maybe<IngredientUpdateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientUpdateManyInput>;
}

export interface RecipeInstructionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockIndex?: Maybe<Int>;
  blockIndex_not?: Maybe<Int>;
  blockIndex_in?: Maybe<Int[] | Int>;
  blockIndex_not_in?: Maybe<Int[] | Int>;
  blockIndex_lt?: Maybe<Int>;
  blockIndex_lte?: Maybe<Int>;
  blockIndex_gt?: Maybe<Int>;
  blockIndex_gte?: Maybe<Int>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  AND?: Maybe<RecipeInstructionWhereInput[] | RecipeInstructionWhereInput>;
  OR?: Maybe<RecipeInstructionWhereInput[] | RecipeInstructionWhereInput>;
  NOT?: Maybe<RecipeInstructionWhereInput[] | RecipeInstructionWhereInput>;
}

export interface AlternateNameUpdateManyInput {
  create?: Maybe<AlternateNameCreateInput[] | AlternateNameCreateInput>;
  update?: Maybe<
    | AlternateNameUpdateWithWhereUniqueNestedInput[]
    | AlternateNameUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AlternateNameUpsertWithWhereUniqueNestedInput[]
    | AlternateNameUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput
  >;
  connect?: Maybe<
    AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput
  >;
  set?: Maybe<AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput>;
  disconnect?: Maybe<
    AlternateNameWhereUniqueInput[] | AlternateNameWhereUniqueInput
  >;
  deleteMany?: Maybe<
    AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput
  >;
  updateMany?: Maybe<
    | AlternateNameUpdateManyWithWhereNestedInput[]
    | AlternateNameUpdateManyWithWhereNestedInput
  >;
}

export interface RecipeInstructionUpdateWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput;
  data: RecipeInstructionUpdateDataInput;
}

export interface AlternateNameUpdateWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput;
  data: AlternateNameUpdateDataInput;
}

export interface AlternateNameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AlternateNameWhereInput[] | AlternateNameWhereInput>;
  OR?: Maybe<AlternateNameWhereInput[] | AlternateNameWhereInput>;
  NOT?: Maybe<AlternateNameWhereInput[] | AlternateNameWhereInput>;
}

export interface AlternateNameUpdateDataInput {
  name?: Maybe<String>;
}

export interface TagUpdateManyDataInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface AlternateNameUpsertWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput;
  update: AlternateNameUpdateDataInput;
  create: AlternateNameCreateInput;
}

export type RecipeAggregateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AlternateNameScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput>;
  OR?: Maybe<AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput>;
  NOT?: Maybe<AlternateNameScalarWhereInput[] | AlternateNameScalarWhereInput>;
}

export interface RecipeAggregateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  recipesCount?: Maybe<Int>;
  recipesCount_not?: Maybe<Int>;
  recipesCount_in?: Maybe<Int[] | Int>;
  recipesCount_not_in?: Maybe<Int[] | Int>;
  recipesCount_lt?: Maybe<Int>;
  recipesCount_lte?: Maybe<Int>;
  recipesCount_gt?: Maybe<Int>;
  recipesCount_gte?: Maybe<Int>;
  AND?: Maybe<RecipeAggregateWhereInput[] | RecipeAggregateWhereInput>;
  OR?: Maybe<RecipeAggregateWhereInput[] | RecipeAggregateWhereInput>;
  NOT?: Maybe<RecipeAggregateWhereInput[] | RecipeAggregateWhereInput>;
}

export interface AlternateNameUpdateManyWithWhereNestedInput {
  where: AlternateNameScalarWhereInput;
  data: AlternateNameUpdateManyDataInput;
}

export interface TagUpdateDataInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface AlternateNameUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TagUpdateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  update?: Maybe<
    TagUpdateWithWhereUniqueNestedInput[] | TagUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    TagUpsertWithWhereUniqueNestedInput[] | TagUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagCreateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface CategoryUpdateManyDataInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface PropertiesUpdateDataInput {
  meat?: Maybe<Boolean>;
  poultry?: Maybe<Boolean>;
  fish?: Maybe<Boolean>;
  dairy?: Maybe<Boolean>;
  soy?: Maybe<Boolean>;
  gluten?: Maybe<Boolean>;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  evernoteGUID_not?: Maybe<String>;
  evernoteGUID_in?: Maybe<String[] | String>;
  evernoteGUID_not_in?: Maybe<String[] | String>;
  evernoteGUID_lt?: Maybe<String>;
  evernoteGUID_lte?: Maybe<String>;
  evernoteGUID_gt?: Maybe<String>;
  evernoteGUID_gte?: Maybe<String>;
  evernoteGUID_contains?: Maybe<String>;
  evernoteGUID_not_contains?: Maybe<String>;
  evernoteGUID_starts_with?: Maybe<String>;
  evernoteGUID_not_starts_with?: Maybe<String>;
  evernoteGUID_ends_with?: Maybe<String>;
  evernoteGUID_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface PropertiesUpsertNestedInput {
  update: PropertiesUpdateDataInput;
  create: PropertiesCreateInput;
}

export interface CategoryUpsertWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface IngredientUpdateOneWithoutParentInput {
  create?: Maybe<IngredientCreateWithoutParentInput>;
  update?: Maybe<IngredientUpdateWithoutParentDataInput>;
  upsert?: Maybe<IngredientUpsertWithoutParentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<IngredientWhereUniqueInput>;
}

export interface CategoryUpdateWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateDataInput;
}

export interface IngredientUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameUpdateManyInput>;
  properties?: Maybe<PropertiesUpdateOneRequiredInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  relatedIngredients?: Maybe<
    IngredientUpdateManyWithoutRelatedIngredientsInput
  >;
  substitutes?: Maybe<IngredientUpdateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientUpdateManyInput>;
}

export interface CategoryUpdateManyInput {
  create?: Maybe<CategoryCreateInput[] | CategoryCreateInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueNestedInput[]
    | CategoryUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueNestedInput[]
    | CategoryUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface IngredientUpdateManyWithoutRelatedIngredientsInput {
  create?: Maybe<
    | IngredientCreateWithoutRelatedIngredientsInput[]
    | IngredientCreateWithoutRelatedIngredientsInput
  >;
  delete?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  connect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  set?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  disconnect?: Maybe<IngredientWhereUniqueInput[] | IngredientWhereUniqueInput>;
  update?: Maybe<
    | IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput[]
    | IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput
  >;
  upsert?: Maybe<
    | IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput[]
    | IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput
  >;
  deleteMany?: Maybe<IngredientScalarWhereInput[] | IngredientScalarWhereInput>;
  updateMany?: Maybe<
    | IngredientUpdateManyWithWhereNestedInput[]
    | IngredientUpdateManyWithWhereNestedInput
  >;
}

export interface RecipeInstructionCreateInput {
  id?: Maybe<ID_Input>;
  blockIndex: Int;
  reference: String;
}

export interface IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput;
  data: IngredientUpdateWithoutRelatedIngredientsDataInput;
}

export interface AlternateNameCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface CategoryCreateManyInput {
  create?: Maybe<CategoryCreateInput[] | CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface AlternateNameUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RecipeCreateInput {
  id?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  title: String;
  source?: Maybe<String>;
  categories?: Maybe<CategoryCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
  image?: Maybe<String>;
  ingredients?: Maybe<RecipeIngredientCreateManyInput>;
  instructions?: Maybe<RecipeInstructionCreateManyInput>;
}

export interface RecipeInstructionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RecipeInstructionWhereInput>;
  AND?: Maybe<
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RecipeInstructionSubscriptionWhereInput[]
    | RecipeInstructionSubscriptionWhereInput
  >;
}

export interface IngredientUpdateWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput;
  data: IngredientUpdateWithoutSubstitutesDataInput;
}

export interface RecipeIngredientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockIndex?: Maybe<Int>;
  blockIndex_not?: Maybe<Int>;
  blockIndex_in?: Maybe<Int[] | Int>;
  blockIndex_not_in?: Maybe<Int[] | Int>;
  blockIndex_lt?: Maybe<Int>;
  blockIndex_lte?: Maybe<Int>;
  blockIndex_gt?: Maybe<Int>;
  blockIndex_gte?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  lineIndex_not?: Maybe<Int>;
  lineIndex_in?: Maybe<Int[] | Int>;
  lineIndex_not_in?: Maybe<Int[] | Int>;
  lineIndex_lt?: Maybe<Int>;
  lineIndex_lte?: Maybe<Int>;
  lineIndex_gt?: Maybe<Int>;
  lineIndex_gte?: Maybe<Int>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
  isParsed_not?: Maybe<Boolean>;
  parsed_every?: Maybe<ParsedSegmentWhereInput>;
  parsed_some?: Maybe<ParsedSegmentWhereInput>;
  parsed_none?: Maybe<ParsedSegmentWhereInput>;
  AND?: Maybe<RecipeIngredientWhereInput[] | RecipeIngredientWhereInput>;
  OR?: Maybe<RecipeIngredientWhereInput[] | RecipeIngredientWhereInput>;
  NOT?: Maybe<RecipeIngredientWhereInput[] | RecipeIngredientWhereInput>;
}

export interface IngredientUpdateWithoutSubstitutesDataInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameUpdateManyInput>;
  properties?: Maybe<PropertiesUpdateOneRequiredInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientUpdateOneWithoutParentInput>;
  relatedIngredients?: Maybe<
    IngredientUpdateManyWithoutRelatedIngredientsInput
  >;
  references?: Maybe<RecipeIngredientUpdateManyInput>;
}

export interface RecipeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RecipeWhereInput>;
  AND?: Maybe<RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput>;
  OR?: Maybe<RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput>;
  NOT?: Maybe<RecipeSubscriptionWhereInput[] | RecipeSubscriptionWhereInput>;
}

export interface RecipeIngredientUpdateManyInput {
  create?: Maybe<RecipeIngredientCreateInput[] | RecipeIngredientCreateInput>;
  update?: Maybe<
    | RecipeIngredientUpdateWithWhereUniqueNestedInput[]
    | RecipeIngredientUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RecipeIngredientUpsertWithWhereUniqueNestedInput[]
    | RecipeIngredientUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput
  >;
  connect?: Maybe<
    RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput
  >;
  set?: Maybe<
    RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput
  >;
  disconnect?: Maybe<
    RecipeIngredientWhereUniqueInput[] | RecipeIngredientWhereUniqueInput
  >;
  deleteMany?: Maybe<
    RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput
  >;
  updateMany?: Maybe<
    | RecipeIngredientUpdateManyWithWhereNestedInput[]
    | RecipeIngredientUpdateManyWithWhereNestedInput
  >;
}

export interface IngredientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IngredientWhereInput>;
  AND?: Maybe<
    IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput
  >;
  OR?: Maybe<
    IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput
  >;
  NOT?: Maybe<
    IngredientSubscriptionWhereInput[] | IngredientSubscriptionWhereInput
  >;
}

export interface RecipeIngredientUpdateWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput;
  data: RecipeIngredientUpdateDataInput;
}

export interface IngredientAggregateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  ingredientsCount?: Maybe<Int>;
  ingredientsCount_not?: Maybe<Int>;
  ingredientsCount_in?: Maybe<Int[] | Int>;
  ingredientsCount_not_in?: Maybe<Int[] | Int>;
  ingredientsCount_lt?: Maybe<Int>;
  ingredientsCount_lte?: Maybe<Int>;
  ingredientsCount_gt?: Maybe<Int>;
  ingredientsCount_gte?: Maybe<Int>;
  newIngredientsCount?: Maybe<Int>;
  newIngredientsCount_not?: Maybe<Int>;
  newIngredientsCount_in?: Maybe<Int[] | Int>;
  newIngredientsCount_not_in?: Maybe<Int[] | Int>;
  newIngredientsCount_lt?: Maybe<Int>;
  newIngredientsCount_lte?: Maybe<Int>;
  newIngredientsCount_gt?: Maybe<Int>;
  newIngredientsCount_gte?: Maybe<Int>;
  AND?: Maybe<IngredientAggregateWhereInput[] | IngredientAggregateWhereInput>;
  OR?: Maybe<IngredientAggregateWhereInput[] | IngredientAggregateWhereInput>;
  NOT?: Maybe<IngredientAggregateWhereInput[] | IngredientAggregateWhereInput>;
}

export interface RecipeIngredientUpdateDataInput {
  blockIndex?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  reference?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
  parsed?: Maybe<ParsedSegmentUpdateManyInput>;
}

export interface RecipeInstructionUpdateInput {
  blockIndex?: Maybe<Int>;
  reference?: Maybe<String>;
}

export interface ParsedSegmentUpdateManyInput {
  create?: Maybe<ParsedSegmentCreateInput[] | ParsedSegmentCreateInput>;
  update?: Maybe<
    | ParsedSegmentUpdateWithWhereUniqueNestedInput[]
    | ParsedSegmentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ParsedSegmentUpsertWithWhereUniqueNestedInput[]
    | ParsedSegmentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput
  >;
  connect?: Maybe<
    ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput
  >;
  set?: Maybe<ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput>;
  disconnect?: Maybe<
    ParsedSegmentWhereUniqueInput[] | ParsedSegmentWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | ParsedSegmentUpdateManyWithWhereNestedInput[]
    | ParsedSegmentUpdateManyWithWhereNestedInput
  >;
}

export interface RecipeAggregateUpdateManyMutationInput {
  recipesCount?: Maybe<Int>;
}

export interface ParsedSegmentUpdateWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput;
  data: ParsedSegmentUpdateDataInput;
}

export interface RecipeUpdateManyMutationInput {
  evernoteGUID?: Maybe<String>;
  title?: Maybe<String>;
  source?: Maybe<String>;
  image?: Maybe<String>;
}

export interface ParsedSegmentUpdateDataInput {
  rule?: Maybe<String>;
  type?: Maybe<String>;
  value?: Maybe<String>;
  ingredient?: Maybe<IngredientUpdateOneInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  evernoteGUID_not?: Maybe<String>;
  evernoteGUID_in?: Maybe<String[] | String>;
  evernoteGUID_not_in?: Maybe<String[] | String>;
  evernoteGUID_lt?: Maybe<String>;
  evernoteGUID_lte?: Maybe<String>;
  evernoteGUID_gt?: Maybe<String>;
  evernoteGUID_gte?: Maybe<String>;
  evernoteGUID_contains?: Maybe<String>;
  evernoteGUID_not_contains?: Maybe<String>;
  evernoteGUID_starts_with?: Maybe<String>;
  evernoteGUID_not_starts_with?: Maybe<String>;
  evernoteGUID_ends_with?: Maybe<String>;
  evernoteGUID_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface IngredientUpdateOneInput {
  create?: Maybe<IngredientCreateInput>;
  update?: Maybe<IngredientUpdateDataInput>;
  upsert?: Maybe<IngredientUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<IngredientWhereUniqueInput>;
}

export interface RecipeInstructionUpdateDataInput {
  blockIndex?: Maybe<Int>;
  reference?: Maybe<String>;
}

export interface IngredientUpdateDataInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  alternateNames?: Maybe<AlternateNameUpdateManyInput>;
  properties?: Maybe<PropertiesUpdateOneRequiredInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  parent?: Maybe<IngredientUpdateOneWithoutParentInput>;
  relatedIngredients?: Maybe<
    IngredientUpdateManyWithoutRelatedIngredientsInput
  >;
  substitutes?: Maybe<IngredientUpdateManyWithoutSubstitutesInput>;
  references?: Maybe<RecipeIngredientUpdateManyInput>;
}

export interface RecipeInstructionUpdateManyInput {
  create?: Maybe<RecipeInstructionCreateInput[] | RecipeInstructionCreateInput>;
  update?: Maybe<
    | RecipeInstructionUpdateWithWhereUniqueNestedInput[]
    | RecipeInstructionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RecipeInstructionUpsertWithWhereUniqueNestedInput[]
    | RecipeInstructionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput
  >;
  connect?: Maybe<
    RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput
  >;
  set?: Maybe<
    RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput
  >;
  disconnect?: Maybe<
    RecipeInstructionWhereUniqueInput[] | RecipeInstructionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    RecipeInstructionScalarWhereInput[] | RecipeInstructionScalarWhereInput
  >;
  updateMany?: Maybe<
    | RecipeInstructionUpdateManyWithWhereNestedInput[]
    | RecipeInstructionUpdateManyWithWhereNestedInput
  >;
}

export interface IngredientUpsertNestedInput {
  update: IngredientUpdateDataInput;
  create: IngredientCreateInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  evernoteGUID_not?: Maybe<String>;
  evernoteGUID_in?: Maybe<String[] | String>;
  evernoteGUID_not_in?: Maybe<String[] | String>;
  evernoteGUID_lt?: Maybe<String>;
  evernoteGUID_lte?: Maybe<String>;
  evernoteGUID_gt?: Maybe<String>;
  evernoteGUID_gte?: Maybe<String>;
  evernoteGUID_contains?: Maybe<String>;
  evernoteGUID_not_contains?: Maybe<String>;
  evernoteGUID_starts_with?: Maybe<String>;
  evernoteGUID_not_starts_with?: Maybe<String>;
  evernoteGUID_ends_with?: Maybe<String>;
  evernoteGUID_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface ParsedSegmentUpsertWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput;
  update: ParsedSegmentUpdateDataInput;
  create: ParsedSegmentCreateInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface ParsedSegmentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rule?: Maybe<String>;
  rule_not?: Maybe<String>;
  rule_in?: Maybe<String[] | String>;
  rule_not_in?: Maybe<String[] | String>;
  rule_lt?: Maybe<String>;
  rule_lte?: Maybe<String>;
  rule_gt?: Maybe<String>;
  rule_gte?: Maybe<String>;
  rule_contains?: Maybe<String>;
  rule_not_contains?: Maybe<String>;
  rule_starts_with?: Maybe<String>;
  rule_not_starts_with?: Maybe<String>;
  rule_ends_with?: Maybe<String>;
  rule_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput>;
  OR?: Maybe<ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput>;
  NOT?: Maybe<ParsedSegmentScalarWhereInput[] | ParsedSegmentScalarWhereInput>;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface ParsedSegmentUpdateManyWithWhereNestedInput {
  where: ParsedSegmentScalarWhereInput;
  data: ParsedSegmentUpdateManyDataInput;
}

export interface CategoryUpdateDataInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface ParsedSegmentUpdateManyDataInput {
  rule?: Maybe<String>;
  type?: Maybe<String>;
  value?: Maybe<String>;
}

export interface RecipeUpdateInput {
  evernoteGUID?: Maybe<String>;
  title?: Maybe<String>;
  source?: Maybe<String>;
  categories?: Maybe<CategoryUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  image?: Maybe<String>;
  ingredients?: Maybe<RecipeIngredientUpdateManyInput>;
  instructions?: Maybe<RecipeInstructionUpdateManyInput>;
}

export interface RecipeIngredientUpsertWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput;
  update: RecipeIngredientUpdateDataInput;
  create: RecipeIngredientCreateInput;
}

export interface AlternateNameUpdateInput {
  name?: Maybe<String>;
}

export interface RecipeIngredientScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockIndex?: Maybe<Int>;
  blockIndex_not?: Maybe<Int>;
  blockIndex_in?: Maybe<Int[] | Int>;
  blockIndex_not_in?: Maybe<Int[] | Int>;
  blockIndex_lt?: Maybe<Int>;
  blockIndex_lte?: Maybe<Int>;
  blockIndex_gt?: Maybe<Int>;
  blockIndex_gte?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  lineIndex_not?: Maybe<Int>;
  lineIndex_in?: Maybe<Int[] | Int>;
  lineIndex_not_in?: Maybe<Int[] | Int>;
  lineIndex_lt?: Maybe<Int>;
  lineIndex_lte?: Maybe<Int>;
  lineIndex_gt?: Maybe<Int>;
  lineIndex_gte?: Maybe<Int>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
  isParsed_not?: Maybe<Boolean>;
  AND?: Maybe<
    RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput
  >;
  OR?: Maybe<
    RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput
  >;
  NOT?: Maybe<
    RecipeIngredientScalarWhereInput[] | RecipeIngredientScalarWhereInput
  >;
}

export interface IngredientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  plural?: Maybe<String>;
  plural_not?: Maybe<String>;
  plural_in?: Maybe<String[] | String>;
  plural_not_in?: Maybe<String[] | String>;
  plural_lt?: Maybe<String>;
  plural_lte?: Maybe<String>;
  plural_gt?: Maybe<String>;
  plural_gte?: Maybe<String>;
  plural_contains?: Maybe<String>;
  plural_not_contains?: Maybe<String>;
  plural_starts_with?: Maybe<String>;
  plural_not_starts_with?: Maybe<String>;
  plural_ends_with?: Maybe<String>;
  plural_not_ends_with?: Maybe<String>;
  alternateNames_every?: Maybe<AlternateNameWhereInput>;
  alternateNames_some?: Maybe<AlternateNameWhereInput>;
  alternateNames_none?: Maybe<AlternateNameWhereInput>;
  properties?: Maybe<PropertiesWhereInput>;
  isComposedIngredient?: Maybe<Boolean>;
  isComposedIngredient_not?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  isValidated_not?: Maybe<Boolean>;
  parent?: Maybe<IngredientWhereInput>;
  relatedIngredients_every?: Maybe<IngredientWhereInput>;
  relatedIngredients_some?: Maybe<IngredientWhereInput>;
  relatedIngredients_none?: Maybe<IngredientWhereInput>;
  substitutes_every?: Maybe<IngredientWhereInput>;
  substitutes_some?: Maybe<IngredientWhereInput>;
  substitutes_none?: Maybe<IngredientWhereInput>;
  references_every?: Maybe<RecipeIngredientWhereInput>;
  references_some?: Maybe<RecipeIngredientWhereInput>;
  references_none?: Maybe<RecipeIngredientWhereInput>;
  AND?: Maybe<IngredientWhereInput[] | IngredientWhereInput>;
  OR?: Maybe<IngredientWhereInput[] | IngredientWhereInput>;
  NOT?: Maybe<IngredientWhereInput[] | IngredientWhereInput>;
}

export interface RecipeIngredientUpdateManyWithWhereNestedInput {
  where: RecipeIngredientScalarWhereInput;
  data: RecipeIngredientUpdateManyDataInput;
}

export interface ParsedSegmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParsedSegmentWhereInput>;
  AND?: Maybe<
    ParsedSegmentSubscriptionWhereInput[] | ParsedSegmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParsedSegmentSubscriptionWhereInput[] | ParsedSegmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParsedSegmentSubscriptionWhereInput[] | ParsedSegmentSubscriptionWhereInput
  >;
}

export interface RecipeIngredientUpdateManyDataInput {
  blockIndex?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  reference?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
}

export interface TagUpdateInput {
  evernoteGUID?: Maybe<String>;
  name?: Maybe<String>;
}

export interface IngredientUpsertWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput;
  update: IngredientUpdateWithoutSubstitutesDataInput;
  create: IngredientCreateWithoutSubstitutesInput;
}

export interface RecipeAggregateUpdateInput {
  recipesCount?: Maybe<Int>;
}

export interface IngredientScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  plural?: Maybe<String>;
  plural_not?: Maybe<String>;
  plural_in?: Maybe<String[] | String>;
  plural_not_in?: Maybe<String[] | String>;
  plural_lt?: Maybe<String>;
  plural_lte?: Maybe<String>;
  plural_gt?: Maybe<String>;
  plural_gte?: Maybe<String>;
  plural_contains?: Maybe<String>;
  plural_not_contains?: Maybe<String>;
  plural_starts_with?: Maybe<String>;
  plural_not_starts_with?: Maybe<String>;
  plural_ends_with?: Maybe<String>;
  plural_not_ends_with?: Maybe<String>;
  isComposedIngredient?: Maybe<Boolean>;
  isComposedIngredient_not?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
  isValidated_not?: Maybe<Boolean>;
  AND?: Maybe<IngredientScalarWhereInput[] | IngredientScalarWhereInput>;
  OR?: Maybe<IngredientScalarWhereInput[] | IngredientScalarWhereInput>;
  NOT?: Maybe<IngredientScalarWhereInput[] | IngredientScalarWhereInput>;
}

export interface RecipeInstructionUpsertWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput;
  update: RecipeInstructionUpdateDataInput;
  create: RecipeInstructionCreateInput;
}

export interface IngredientUpdateManyWithWhereNestedInput {
  where: IngredientScalarWhereInput;
  data: IngredientUpdateManyDataInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface IngredientUpdateManyDataInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
}

export type RecipeIngredientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput;
  update: IngredientUpdateWithoutRelatedIngredientsDataInput;
  create: IngredientCreateWithoutRelatedIngredientsInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface IngredientUpsertWithoutParentInput {
  update: IngredientUpdateWithoutParentDataInput;
  create: IngredientCreateWithoutParentInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface IngredientUpdateManyMutationInput {
  name?: Maybe<String>;
  plural?: Maybe<String>;
  isComposedIngredient?: Maybe<Boolean>;
  isValidated?: Maybe<Boolean>;
}

export type IngredientAggregateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IngredientAggregateCreateInput {
  id?: Maybe<ID_Input>;
  ingredientsCount: Int;
  newIngredientsCount: Int;
}

export type RecipeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IngredientAggregateUpdateInput {
  ingredientsCount?: Maybe<Int>;
  newIngredientsCount?: Maybe<Int>;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface PropertiesUpdateInput {
  meat?: Maybe<Boolean>;
  poultry?: Maybe<Boolean>;
  fish?: Maybe<Boolean>;
  dairy?: Maybe<Boolean>;
  soy?: Maybe<Boolean>;
  gluten?: Maybe<Boolean>;
}

export interface ParsedSegmentUpdateManyMutationInput {
  rule?: Maybe<String>;
  type?: Maybe<String>;
  value?: Maybe<String>;
}

export interface ParsedSegmentUpdateInput {
  rule?: Maybe<String>;
  type?: Maybe<String>;
  value?: Maybe<String>;
  ingredient?: Maybe<IngredientUpdateOneInput>;
}

export interface IngredientAggregateUpdateManyMutationInput {
  ingredientsCount?: Maybe<Int>;
  newIngredientsCount?: Maybe<Int>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type RecipeInstructionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RecipeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  evernoteGUID?: Maybe<String>;
  evernoteGUID_not?: Maybe<String>;
  evernoteGUID_in?: Maybe<String[] | String>;
  evernoteGUID_not_in?: Maybe<String[] | String>;
  evernoteGUID_lt?: Maybe<String>;
  evernoteGUID_lte?: Maybe<String>;
  evernoteGUID_gt?: Maybe<String>;
  evernoteGUID_gte?: Maybe<String>;
  evernoteGUID_contains?: Maybe<String>;
  evernoteGUID_not_contains?: Maybe<String>;
  evernoteGUID_starts_with?: Maybe<String>;
  evernoteGUID_not_starts_with?: Maybe<String>;
  evernoteGUID_ends_with?: Maybe<String>;
  evernoteGUID_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  categories_every?: Maybe<CategoryWhereInput>;
  categories_some?: Maybe<CategoryWhereInput>;
  categories_none?: Maybe<CategoryWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  ingredients_every?: Maybe<RecipeIngredientWhereInput>;
  ingredients_some?: Maybe<RecipeIngredientWhereInput>;
  ingredients_none?: Maybe<RecipeIngredientWhereInput>;
  instructions_every?: Maybe<RecipeInstructionWhereInput>;
  instructions_some?: Maybe<RecipeInstructionWhereInput>;
  instructions_none?: Maybe<RecipeInstructionWhereInput>;
  AND?: Maybe<RecipeWhereInput[] | RecipeWhereInput>;
  OR?: Maybe<RecipeWhereInput[] | RecipeWhereInput>;
  NOT?: Maybe<RecipeWhereInput[] | RecipeWhereInput>;
}

export interface RecipeIngredientUpdateManyMutationInput {
  blockIndex?: Maybe<Int>;
  lineIndex?: Maybe<Int>;
  reference?: Maybe<String>;
  isParsed?: Maybe<Boolean>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TagPreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface IngredientAggregateConnection {
  pageInfo: PageInfo;
  edges: IngredientAggregateEdge[];
}

export interface IngredientAggregateConnectionPromise
  extends Promise<IngredientAggregateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IngredientAggregateEdge>>() => T;
  aggregate: <T = AggregateIngredientAggregatePromise>() => T;
}

export interface IngredientAggregateConnectionSubscription
  extends Promise<AsyncIterator<IngredientAggregateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<IngredientAggregateEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateIngredientAggregateSubscription>() => T;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface IngredientAggregateEdge {
  node: IngredientAggregate;
  cursor: String;
}

export interface IngredientAggregateEdgePromise
  extends Promise<IngredientAggregateEdge>,
    Fragmentable {
  node: <T = IngredientAggregatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface IngredientAggregateEdgeSubscription
  extends Promise<AsyncIterator<IngredientAggregateEdge>>,
    Fragmentable {
  node: <T = IngredientAggregateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeInstructionSubscriptionPayload {
  mutation: MutationType;
  node: RecipeInstruction;
  updatedFields: String[];
  previousValues: RecipeInstructionPreviousValues;
}

export interface RecipeInstructionSubscriptionPayloadPromise
  extends Promise<RecipeInstructionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipeInstructionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipeInstructionPreviousValuesPromise>() => T;
}

export interface RecipeInstructionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeInstructionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeInstructionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipeInstructionPreviousValuesSubscription>() => T;
}

export interface Category {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IngredientAggregate {
  id: ID_Output;
  ingredientsCount: Int;
  newIngredientsCount: Int;
}

export interface IngredientAggregatePromise
  extends Promise<IngredientAggregate>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ingredientsCount: () => Promise<Int>;
  newIngredientsCount: () => Promise<Int>;
}

export interface IngredientAggregateSubscription
  extends Promise<AsyncIterator<IngredientAggregate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ingredientsCount: () => Promise<AsyncIterator<Int>>;
  newIngredientsCount: () => Promise<AsyncIterator<Int>>;
}

export interface IngredientAggregateNullablePromise
  extends Promise<IngredientAggregate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ingredientsCount: () => Promise<Int>;
  newIngredientsCount: () => Promise<Int>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface RecipeInstructionPreviousValues {
  id: ID_Output;
  blockIndex: Int;
  reference: String;
}

export interface RecipeInstructionPreviousValuesPromise
  extends Promise<RecipeInstructionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  reference: () => Promise<String>;
}

export interface RecipeInstructionPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipeInstructionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface RecipeInstructionEdge {
  node: RecipeInstruction;
  cursor: String;
}

export interface RecipeInstructionEdgePromise
  extends Promise<RecipeInstructionEdge>,
    Fragmentable {
  node: <T = RecipeInstructionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeInstructionEdgeSubscription
  extends Promise<AsyncIterator<RecipeInstructionEdge>>,
    Fragmentable {
  node: <T = RecipeInstructionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlternateNameSubscriptionPayload {
  mutation: MutationType;
  node: AlternateName;
  updatedFields: String[];
  previousValues: AlternateNamePreviousValues;
}

export interface AlternateNameSubscriptionPayloadPromise
  extends Promise<AlternateNameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlternateNamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlternateNamePreviousValuesPromise>() => T;
}

export interface AlternateNameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlternateNameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlternateNameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlternateNamePreviousValuesSubscription>() => T;
}

export interface AggregateRecipeIngredient {
  count: Int;
}

export interface AggregateRecipeIngredientPromise
  extends Promise<AggregateRecipeIngredient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeIngredientSubscription
  extends Promise<AsyncIterator<AggregateRecipeIngredient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlternateNamePreviousValues {
  id: ID_Output;
  name: String;
}

export interface AlternateNamePreviousValuesPromise
  extends Promise<AlternateNamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AlternateNamePreviousValuesSubscription
  extends Promise<AsyncIterator<AlternateNamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RecipeIngredientConnection {
  pageInfo: PageInfo;
  edges: RecipeIngredientEdge[];
}

export interface RecipeIngredientConnectionPromise
  extends Promise<RecipeIngredientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeIngredientEdge>>() => T;
  aggregate: <T = AggregateRecipeIngredientPromise>() => T;
}

export interface RecipeIngredientConnectionSubscription
  extends Promise<AsyncIterator<RecipeIngredientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeIngredientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeIngredientSubscription>() => T;
}

export interface AggregateIngredient {
  count: Int;
}

export interface AggregateIngredientPromise
  extends Promise<AggregateIngredient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIngredientSubscription
  extends Promise<AsyncIterator<AggregateIngredient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeAggregateEdge {
  node: RecipeAggregate;
  cursor: String;
}

export interface RecipeAggregateEdgePromise
  extends Promise<RecipeAggregateEdge>,
    Fragmentable {
  node: <T = RecipeAggregatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeAggregateEdgeSubscription
  extends Promise<AsyncIterator<RecipeAggregateEdge>>,
    Fragmentable {
  node: <T = RecipeAggregateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface AlternateName {
  id: ID_Output;
  name: String;
}

export interface AlternateNamePromise
  extends Promise<AlternateName>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AlternateNameSubscription
  extends Promise<AsyncIterator<AlternateName>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AlternateNameNullablePromise
  extends Promise<AlternateName | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRecipe {
  count: Int;
}

export interface AggregateRecipePromise
  extends Promise<AggregateRecipe>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeSubscription
  extends Promise<AsyncIterator<AggregateRecipe>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IngredientEdge {
  node: Ingredient;
  cursor: String;
}

export interface IngredientEdgePromise
  extends Promise<IngredientEdge>,
    Fragmentable {
  node: <T = IngredientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IngredientEdgeSubscription
  extends Promise<AsyncIterator<IngredientEdge>>,
    Fragmentable {
  node: <T = IngredientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeConnection {
  pageInfo: PageInfo;
  edges: RecipeEdge[];
}

export interface RecipeConnectionPromise
  extends Promise<RecipeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeEdge>>() => T;
  aggregate: <T = AggregateRecipePromise>() => T;
}

export interface RecipeConnectionSubscription
  extends Promise<AsyncIterator<RecipeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeSubscription>() => T;
}

export interface IngredientSubscriptionPayload {
  mutation: MutationType;
  node: Ingredient;
  updatedFields: String[];
  previousValues: IngredientPreviousValues;
}

export interface IngredientSubscriptionPayloadPromise
  extends Promise<IngredientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IngredientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IngredientPreviousValuesPromise>() => T;
}

export interface IngredientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IngredientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IngredientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IngredientPreviousValuesSubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface IngredientPreviousValues {
  id: ID_Output;
  name: String;
  plural?: String;
  isComposedIngredient: Boolean;
  isValidated: Boolean;
}

export interface IngredientPreviousValuesPromise
  extends Promise<IngredientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  plural: () => Promise<String>;
  isComposedIngredient: () => Promise<Boolean>;
  isValidated: () => Promise<Boolean>;
}

export interface IngredientPreviousValuesSubscription
  extends Promise<AsyncIterator<IngredientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  plural: () => Promise<AsyncIterator<String>>;
  isComposedIngredient: () => Promise<AsyncIterator<Boolean>>;
  isValidated: () => Promise<AsyncIterator<Boolean>>;
}

export interface AlternateNameConnection {
  pageInfo: PageInfo;
  edges: AlternateNameEdge[];
}

export interface AlternateNameConnectionPromise
  extends Promise<AlternateNameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlternateNameEdge>>() => T;
  aggregate: <T = AggregateAlternateNamePromise>() => T;
}

export interface AlternateNameConnectionSubscription
  extends Promise<AsyncIterator<AlternateNameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlternateNameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlternateNameSubscription>() => T;
}

export interface IngredientConnection {
  pageInfo: PageInfo;
  edges: IngredientEdge[];
}

export interface IngredientConnectionPromise
  extends Promise<IngredientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IngredientEdge>>() => T;
  aggregate: <T = AggregateIngredientPromise>() => T;
}

export interface IngredientConnectionSubscription
  extends Promise<AsyncIterator<IngredientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IngredientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIngredientSubscription>() => T;
}

export interface AggregateProperties {
  count: Int;
}

export interface AggregatePropertiesPromise
  extends Promise<AggregateProperties>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePropertiesSubscription
  extends Promise<AsyncIterator<AggregateProperties>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IngredientAggregateSubscriptionPayload {
  mutation: MutationType;
  node: IngredientAggregate;
  updatedFields: String[];
  previousValues: IngredientAggregatePreviousValues;
}

export interface IngredientAggregateSubscriptionPayloadPromise
  extends Promise<IngredientAggregateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IngredientAggregatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IngredientAggregatePreviousValuesPromise>() => T;
}

export interface IngredientAggregateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IngredientAggregateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IngredientAggregateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IngredientAggregatePreviousValuesSubscription>() => T;
}

export interface PropertiesConnection {
  pageInfo: PageInfo;
  edges: PropertiesEdge[];
}

export interface PropertiesConnectionPromise
  extends Promise<PropertiesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PropertiesEdge>>() => T;
  aggregate: <T = AggregatePropertiesPromise>() => T;
}

export interface PropertiesConnectionSubscription
  extends Promise<AsyncIterator<PropertiesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PropertiesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePropertiesSubscription>() => T;
}

export interface IngredientAggregatePreviousValues {
  id: ID_Output;
  ingredientsCount: Int;
  newIngredientsCount: Int;
}

export interface IngredientAggregatePreviousValuesPromise
  extends Promise<IngredientAggregatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ingredientsCount: () => Promise<Int>;
  newIngredientsCount: () => Promise<Int>;
}

export interface IngredientAggregatePreviousValuesSubscription
  extends Promise<AsyncIterator<IngredientAggregatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ingredientsCount: () => Promise<AsyncIterator<Int>>;
  newIngredientsCount: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateParsedSegment {
  count: Int;
}

export interface AggregateParsedSegmentPromise
  extends Promise<AggregateParsedSegment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParsedSegmentSubscription
  extends Promise<AsyncIterator<AggregateParsedSegment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParsedSegment {
  id: ID_Output;
  rule: String;
  type: String;
  value: String;
}

export interface ParsedSegmentPromise
  extends Promise<ParsedSegment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rule: () => Promise<String>;
  type: () => Promise<String>;
  value: () => Promise<String>;
  ingredient: <T = IngredientPromise>() => T;
}

export interface ParsedSegmentSubscription
  extends Promise<AsyncIterator<ParsedSegment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rule: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  ingredient: <T = IngredientSubscription>() => T;
}

export interface ParsedSegmentNullablePromise
  extends Promise<ParsedSegment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rule: () => Promise<String>;
  type: () => Promise<String>;
  value: () => Promise<String>;
  ingredient: <T = IngredientPromise>() => T;
}

export interface ParsedSegmentConnection {
  pageInfo: PageInfo;
  edges: ParsedSegmentEdge[];
}

export interface ParsedSegmentConnectionPromise
  extends Promise<ParsedSegmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParsedSegmentEdge>>() => T;
  aggregate: <T = AggregateParsedSegmentPromise>() => T;
}

export interface ParsedSegmentConnectionSubscription
  extends Promise<AsyncIterator<ParsedSegmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParsedSegmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParsedSegmentSubscription>() => T;
}

export interface ParsedSegmentSubscriptionPayload {
  mutation: MutationType;
  node: ParsedSegment;
  updatedFields: String[];
  previousValues: ParsedSegmentPreviousValues;
}

export interface ParsedSegmentSubscriptionPayloadPromise
  extends Promise<ParsedSegmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParsedSegmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParsedSegmentPreviousValuesPromise>() => T;
}

export interface ParsedSegmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParsedSegmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParsedSegmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParsedSegmentPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ParsedSegmentPreviousValues {
  id: ID_Output;
  rule: String;
  type: String;
  value: String;
}

export interface ParsedSegmentPreviousValuesPromise
  extends Promise<ParsedSegmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rule: () => Promise<String>;
  type: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ParsedSegmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParsedSegmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rule: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRecipeInstruction {
  count: Int;
}

export interface AggregateRecipeInstructionPromise
  extends Promise<AggregateRecipeInstruction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeInstructionSubscription
  extends Promise<AsyncIterator<AggregateRecipeInstruction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlternateNameEdge {
  node: AlternateName;
  cursor: String;
}

export interface AlternateNameEdgePromise
  extends Promise<AlternateNameEdge>,
    Fragmentable {
  node: <T = AlternateNamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlternateNameEdgeSubscription
  extends Promise<AsyncIterator<AlternateNameEdge>>,
    Fragmentable {
  node: <T = AlternateNameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeIngredientEdge {
  node: RecipeIngredient;
  cursor: String;
}

export interface RecipeIngredientEdgePromise
  extends Promise<RecipeIngredientEdge>,
    Fragmentable {
  node: <T = RecipeIngredientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeIngredientEdgeSubscription
  extends Promise<AsyncIterator<RecipeIngredientEdge>>,
    Fragmentable {
  node: <T = RecipeIngredientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PropertiesSubscriptionPayload {
  mutation: MutationType;
  node: Properties;
  updatedFields: String[];
  previousValues: PropertiesPreviousValues;
}

export interface PropertiesSubscriptionPayloadPromise
  extends Promise<PropertiesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PropertiesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PropertiesPreviousValuesPromise>() => T;
}

export interface PropertiesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PropertiesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PropertiesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PropertiesPreviousValuesSubscription>() => T;
}

export interface RecipeAggregateConnection {
  pageInfo: PageInfo;
  edges: RecipeAggregateEdge[];
}

export interface RecipeAggregateConnectionPromise
  extends Promise<RecipeAggregateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeAggregateEdge>>() => T;
  aggregate: <T = AggregateRecipeAggregatePromise>() => T;
}

export interface RecipeAggregateConnectionSubscription
  extends Promise<AsyncIterator<RecipeAggregateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeAggregateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeAggregateSubscription>() => T;
}

export interface PropertiesPreviousValues {
  id: ID_Output;
  meat: Boolean;
  poultry: Boolean;
  fish: Boolean;
  dairy: Boolean;
  soy: Boolean;
  gluten: Boolean;
}

export interface PropertiesPreviousValuesPromise
  extends Promise<PropertiesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  meat: () => Promise<Boolean>;
  poultry: () => Promise<Boolean>;
  fish: () => Promise<Boolean>;
  dairy: () => Promise<Boolean>;
  soy: () => Promise<Boolean>;
  gluten: () => Promise<Boolean>;
}

export interface PropertiesPreviousValuesSubscription
  extends Promise<AsyncIterator<PropertiesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  meat: () => Promise<AsyncIterator<Boolean>>;
  poultry: () => Promise<AsyncIterator<Boolean>>;
  fish: () => Promise<AsyncIterator<Boolean>>;
  dairy: () => Promise<AsyncIterator<Boolean>>;
  soy: () => Promise<AsyncIterator<Boolean>>;
  gluten: () => Promise<AsyncIterator<Boolean>>;
}

export interface RecipeEdge {
  node: Recipe;
  cursor: String;
}

export interface RecipeEdgePromise extends Promise<RecipeEdge>, Fragmentable {
  node: <T = RecipePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipeEdgeSubscription
  extends Promise<AsyncIterator<RecipeEdge>>,
    Fragmentable {
  node: <T = RecipeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeIngredient {
  id: ID_Output;
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed: Boolean;
}

export interface RecipeIngredientPromise
  extends Promise<RecipeIngredient>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  lineIndex: () => Promise<Int>;
  reference: () => Promise<String>;
  isParsed: () => Promise<Boolean>;
  parsed: <T = FragmentableArray<ParsedSegment>>(args?: {
    where?: ParsedSegmentWhereInput;
    orderBy?: ParsedSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeIngredientSubscription
  extends Promise<AsyncIterator<RecipeIngredient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  lineIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
  isParsed: () => Promise<AsyncIterator<Boolean>>;
  parsed: <T = Promise<AsyncIterator<ParsedSegmentSubscription>>>(args?: {
    where?: ParsedSegmentWhereInput;
    orderBy?: ParsedSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeIngredientNullablePromise
  extends Promise<RecipeIngredient | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  lineIndex: () => Promise<Int>;
  reference: () => Promise<String>;
  isParsed: () => Promise<Boolean>;
  parsed: <T = FragmentableArray<ParsedSegment>>(args?: {
    where?: ParsedSegmentWhereInput;
    orderBy?: ParsedSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Tag {
  id: ID_Output;
  evernoteGUID?: String;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  name: () => Promise<String>;
}

export interface RecipeSubscriptionPayload {
  mutation: MutationType;
  node: Recipe;
  updatedFields: String[];
  previousValues: RecipePreviousValues;
}

export interface RecipeSubscriptionPayloadPromise
  extends Promise<RecipeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipePreviousValuesPromise>() => T;
}

export interface RecipeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipePreviousValuesSubscription>() => T;
}

export interface PropertiesEdge {
  node: Properties;
  cursor: String;
}

export interface PropertiesEdgePromise
  extends Promise<PropertiesEdge>,
    Fragmentable {
  node: <T = PropertiesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PropertiesEdgeSubscription
  extends Promise<AsyncIterator<PropertiesEdge>>,
    Fragmentable {
  node: <T = PropertiesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipePreviousValues {
  id: ID_Output;
  evernoteGUID?: String;
  title: String;
  source?: String;
  image?: String;
}

export interface RecipePreviousValuesPromise
  extends Promise<RecipePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  title: () => Promise<String>;
  source: () => Promise<String>;
  image: () => Promise<String>;
}

export interface RecipePreviousValuesSubscription
  extends Promise<AsyncIterator<RecipePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface ParsedSegmentEdge {
  node: ParsedSegment;
  cursor: String;
}

export interface ParsedSegmentEdgePromise
  extends Promise<ParsedSegmentEdge>,
    Fragmentable {
  node: <T = ParsedSegmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParsedSegmentEdgeSubscription
  extends Promise<AsyncIterator<ParsedSegmentEdge>>,
    Fragmentable {
  node: <T = ParsedSegmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAlternateName {
  count: Int;
}

export interface AggregateAlternateNamePromise
  extends Promise<AggregateAlternateName>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlternateNameSubscription
  extends Promise<AsyncIterator<AggregateAlternateName>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RecipeAggregateSubscriptionPayload {
  mutation: MutationType;
  node: RecipeAggregate;
  updatedFields: String[];
  previousValues: RecipeAggregatePreviousValues;
}

export interface RecipeAggregateSubscriptionPayloadPromise
  extends Promise<RecipeAggregateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipeAggregatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipeAggregatePreviousValuesPromise>() => T;
}

export interface RecipeAggregateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeAggregateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeAggregateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipeAggregatePreviousValuesSubscription>() => T;
}

export interface AggregateRecipeAggregate {
  count: Int;
}

export interface AggregateRecipeAggregatePromise
  extends Promise<AggregateRecipeAggregate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipeAggregateSubscription
  extends Promise<AsyncIterator<AggregateRecipeAggregate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeAggregatePreviousValues {
  id: ID_Output;
  recipesCount: Int;
}

export interface RecipeAggregatePreviousValuesPromise
  extends Promise<RecipeAggregatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  recipesCount: () => Promise<Int>;
}

export interface RecipeAggregatePreviousValuesSubscription
  extends Promise<AsyncIterator<RecipeAggregatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  recipesCount: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeInstruction {
  id: ID_Output;
  blockIndex: Int;
  reference: String;
}

export interface RecipeInstructionPromise
  extends Promise<RecipeInstruction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  reference: () => Promise<String>;
}

export interface RecipeInstructionSubscription
  extends Promise<AsyncIterator<RecipeInstruction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface RecipeInstructionNullablePromise
  extends Promise<RecipeInstruction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  reference: () => Promise<String>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Ingredient {
  id: ID_Output;
  name: String;
  plural?: String;
  isComposedIngredient: Boolean;
  isValidated: Boolean;
}

export interface IngredientPromise extends Promise<Ingredient>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  plural: () => Promise<String>;
  alternateNames: <T = FragmentableArray<AlternateName>>(args?: {
    where?: AlternateNameWhereInput;
    orderBy?: AlternateNameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  properties: <T = PropertiesPromise>() => T;
  isComposedIngredient: () => Promise<Boolean>;
  isValidated: () => Promise<Boolean>;
  parent: <T = IngredientPromise>() => T;
  relatedIngredients: <T = FragmentableArray<Ingredient>>(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  substitutes: <T = FragmentableArray<Ingredient>>(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  references: <T = FragmentableArray<RecipeIngredient>>(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface IngredientSubscription
  extends Promise<AsyncIterator<Ingredient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  plural: () => Promise<AsyncIterator<String>>;
  alternateNames: <
    T = Promise<AsyncIterator<AlternateNameSubscription>>
  >(args?: {
    where?: AlternateNameWhereInput;
    orderBy?: AlternateNameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  properties: <T = PropertiesSubscription>() => T;
  isComposedIngredient: () => Promise<AsyncIterator<Boolean>>;
  isValidated: () => Promise<AsyncIterator<Boolean>>;
  parent: <T = IngredientSubscription>() => T;
  relatedIngredients: <
    T = Promise<AsyncIterator<IngredientSubscription>>
  >(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  substitutes: <T = Promise<AsyncIterator<IngredientSubscription>>>(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  references: <
    T = Promise<AsyncIterator<RecipeIngredientSubscription>>
  >(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface IngredientNullablePromise
  extends Promise<Ingredient | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  plural: () => Promise<String>;
  alternateNames: <T = FragmentableArray<AlternateName>>(args?: {
    where?: AlternateNameWhereInput;
    orderBy?: AlternateNameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  properties: <T = PropertiesPromise>() => T;
  isComposedIngredient: () => Promise<Boolean>;
  isValidated: () => Promise<Boolean>;
  parent: <T = IngredientPromise>() => T;
  relatedIngredients: <T = FragmentableArray<Ingredient>>(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  substitutes: <T = FragmentableArray<Ingredient>>(args?: {
    where?: IngredientWhereInput;
    orderBy?: IngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  references: <T = FragmentableArray<RecipeIngredient>>(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeIngredientPreviousValues {
  id: ID_Output;
  blockIndex: Int;
  lineIndex: Int;
  reference: String;
  isParsed: Boolean;
}

export interface RecipeIngredientPreviousValuesPromise
  extends Promise<RecipeIngredientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockIndex: () => Promise<Int>;
  lineIndex: () => Promise<Int>;
  reference: () => Promise<String>;
  isParsed: () => Promise<Boolean>;
}

export interface RecipeIngredientPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipeIngredientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockIndex: () => Promise<AsyncIterator<Int>>;
  lineIndex: () => Promise<AsyncIterator<Int>>;
  reference: () => Promise<AsyncIterator<String>>;
  isParsed: () => Promise<AsyncIterator<Boolean>>;
}

export interface RecipeIngredientSubscriptionPayload {
  mutation: MutationType;
  node: RecipeIngredient;
  updatedFields: String[];
  previousValues: RecipeIngredientPreviousValues;
}

export interface RecipeIngredientSubscriptionPayloadPromise
  extends Promise<RecipeIngredientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipeIngredientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipeIngredientPreviousValuesPromise>() => T;
}

export interface RecipeIngredientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipeIngredientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipeIngredientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipeIngredientPreviousValuesSubscription>() => T;
}

export interface Properties {
  id: ID_Output;
  meat: Boolean;
  poultry: Boolean;
  fish: Boolean;
  dairy: Boolean;
  soy: Boolean;
  gluten: Boolean;
}

export interface PropertiesPromise extends Promise<Properties>, Fragmentable {
  id: () => Promise<ID_Output>;
  meat: () => Promise<Boolean>;
  poultry: () => Promise<Boolean>;
  fish: () => Promise<Boolean>;
  dairy: () => Promise<Boolean>;
  soy: () => Promise<Boolean>;
  gluten: () => Promise<Boolean>;
}

export interface PropertiesSubscription
  extends Promise<AsyncIterator<Properties>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  meat: () => Promise<AsyncIterator<Boolean>>;
  poultry: () => Promise<AsyncIterator<Boolean>>;
  fish: () => Promise<AsyncIterator<Boolean>>;
  dairy: () => Promise<AsyncIterator<Boolean>>;
  soy: () => Promise<AsyncIterator<Boolean>>;
  gluten: () => Promise<AsyncIterator<Boolean>>;
}

export interface PropertiesNullablePromise
  extends Promise<Properties | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  meat: () => Promise<Boolean>;
  poultry: () => Promise<Boolean>;
  fish: () => Promise<Boolean>;
  dairy: () => Promise<Boolean>;
  soy: () => Promise<Boolean>;
  gluten: () => Promise<Boolean>;
}

export interface AggregateIngredientAggregate {
  count: Int;
}

export interface AggregateIngredientAggregatePromise
  extends Promise<AggregateIngredientAggregate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIngredientAggregateSubscription
  extends Promise<AsyncIterator<AggregateIngredientAggregate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Recipe {
  id: ID_Output;
  evernoteGUID?: String;
  title: String;
  source?: String;
  image?: String;
}

export interface RecipePromise extends Promise<Recipe>, Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  title: () => Promise<String>;
  source: () => Promise<String>;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: () => Promise<String>;
  ingredients: <T = FragmentableArray<RecipeIngredient>>(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instructions: <T = FragmentableArray<RecipeInstruction>>(args?: {
    where?: RecipeInstructionWhereInput;
    orderBy?: RecipeInstructionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeSubscription
  extends Promise<AsyncIterator<Recipe>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  evernoteGUID: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: () => Promise<AsyncIterator<String>>;
  ingredients: <
    T = Promise<AsyncIterator<RecipeIngredientSubscription>>
  >(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instructions: <
    T = Promise<AsyncIterator<RecipeInstructionSubscription>>
  >(args?: {
    where?: RecipeInstructionWhereInput;
    orderBy?: RecipeInstructionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeNullablePromise
  extends Promise<Recipe | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  evernoteGUID: () => Promise<String>;
  title: () => Promise<String>;
  source: () => Promise<String>;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: () => Promise<String>;
  ingredients: <T = FragmentableArray<RecipeIngredient>>(args?: {
    where?: RecipeIngredientWhereInput;
    orderBy?: RecipeIngredientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instructions: <T = FragmentableArray<RecipeInstruction>>(args?: {
    where?: RecipeInstructionWhereInput;
    orderBy?: RecipeInstructionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RecipeAggregate {
  id: ID_Output;
  recipesCount: Int;
}

export interface RecipeAggregatePromise
  extends Promise<RecipeAggregate>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  recipesCount: () => Promise<Int>;
}

export interface RecipeAggregateSubscription
  extends Promise<AsyncIterator<RecipeAggregate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  recipesCount: () => Promise<AsyncIterator<Int>>;
}

export interface RecipeAggregateNullablePromise
  extends Promise<RecipeAggregate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  recipesCount: () => Promise<Int>;
}

export interface RecipeInstructionConnection {
  pageInfo: PageInfo;
  edges: RecipeInstructionEdge[];
}

export interface RecipeInstructionConnectionPromise
  extends Promise<RecipeInstructionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipeInstructionEdge>>() => T;
  aggregate: <T = AggregateRecipeInstructionPromise>() => T;
}

export interface RecipeInstructionConnectionSubscription
  extends Promise<AsyncIterator<RecipeInstructionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipeInstructionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipeInstructionSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Ingredient",
    embedded: false
  },
  {
    name: "AlternateName",
    embedded: false
  },
  {
    name: "Properties",
    embedded: false
  },
  {
    name: "Recipe",
    embedded: false
  },
  {
    name: "RecipeInstruction",
    embedded: false
  },
  {
    name: "RecipeIngredient",
    embedded: false
  },
  {
    name: "ParsedSegment",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "IngredientAggregate",
    embedded: false
  },
  {
    name: "RecipeAggregate",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
